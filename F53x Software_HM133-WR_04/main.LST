C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(2,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /****************************************************************************************
   2           ****************** COPYRIGHT (c) 2020 by Joseph Haas (DBA FF Systems)  *****************
   3           *
   4           *  File name: main.c
   5           *
   6           *  Module:    Control
   7           *
   8           *  Summary:   This is the main code file for the HM133 DTMF application
   9           *      License and other legal stuff:
  10           *                         This software, comprised of all files contained in the original distribution archive,
  11           *                              are protected by US Copyright laws.  The files may be used and modified by the person
  12           *                              receiving them under the following terms and conditions:
  13           *                              1) The software, or any protion thereof may not be distributed to any 3rd party by
  14           *                                      the recipient or any agent or assign of the recipient.
  15           *                              2) The recipient assumes all risks for the use (or mis-use) of this software.
  16           *
  17           *
  18           *  Project scope revision history:
  19           *        *** REV w04r ***
  20           *        06-26-22 jmh:  Deprecated bluetooth remote.  Removed serial input and bluetooth module.  Replaced wit
             -h wired_rmt module.
  21           *                                       Wired remote sends commands in the blind to the target host.
  22           *
  23           *    08-22-20 jmh:  IC901 remote control head mods: Supports a wired-remote master/slave to provide 6 rem
             -ote GPIO signals
  24           *        *** REV 04r ***
  25           *    08-22-20 jmh:  IC901 remote control head mods: Supports a wired-remote master/slave to provide 6 rem
             -ote GPIO signals
  26           *                                       aimed at simulating keypresses on the IC-901 (or, possibly, other) radio control head.
  27           *                                       The uCHIP RN4871 is used as the master (it is smaller, but has limited I/O) and the RN4780 is the 
             -slave.
  28           *                                       The RN4780 has only 5 GPIOs, but one of the PWM outputs is used as a 6th output by operating it at
             - 0.5%
  29           *                                       or 99.5% and filtering out the carrier with an RC filter.  The following summary lists the SW/HW
  30           *                                       modifications made to support this feature:
  31           *
  32           *                                              - re-arranged timers 1 & 2 so that timer1 can drive UART baud clock to 115.556k Kb (0.3% above the
  33           *                                                      nominal 115.2 Kb)
  34           *                                              - added serial.c and modified to interface with BT module comms
  35           *                                              - revamped RAM useage (using "idata" and "data" segment IDs) to get the linker happy again.  The
  36           *                                                      RAM is heavily utilized leaving very little room for error or bloat.
  37           *                                              - added wired-remote.c to hold wired remote process machine and Fns.
  38           *                                              - Tasked P0.6 as the "Mute-on-RX" enable.  Grounding P0.6 enables the SMUTE toggle on PTT edge
  39           *                                                      feature.  Operator configures SMUTE as desired for RX, and the system will enable/disable
  40           *                                                      on PTT edges.  Just in time for Christmas, no less.
  41           *                                              - folded in button tasks in the main() process loop.  Buttons now provide the following functions:
  42           *
  43           *                                                              HM-151 KEYPAD:
  44           *
  45           *                                                              LOCK (L)        TUNER (T)         XFC (X)
  46           *                                                              Scan (up)       CALL              M/S
  47           *
  48           *                                                              upARROW (/)             V/M (V)   MW (M)
  49           *                                                                 UP                     V/M      H/L
  50           *
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 2   

  51           *                                                              dnARROW (\)             F1 (F)    F2 (f)
  52           *                                                                 DN                     SET      SUB
  53           *
  54           *                                                              (1)             (2)             (3)               MODE (A)
  55           *                                                              <Digits 0-9 = DTMF if >     MODE
  56           *
  57           *                                                              (4)             (5)             (6)               FIL  (B)
  58           *                                                              <PTT active, or pulse >     TSQ
  59           *
  60           *                                                              (7)             (8)             (9)               GENE (C)
  61           *                                                              <accum input otherwise>     BAND
  62           *                                                                                                                                                      -% The toggle CHECK feature sets the check switch,
  63           *                                                              . (*)   (0)             CE (#)    ENT  (D)                         then enters a special hold state.  Any bluethooth
  64           *                                                              Togg                    Togg        SMUTE                          key will then open the CHECK button, exit the hold
  65           *                                                              LED brt                 CHECK -%                                           state, and return to normal key operation.
  66           *
  67           *                                                      Characters in () identify the keymap code that is used in the system.  Togg LED Brightness
  68           *                                                      clears the pulse accumulator.
  69           *                      DEPRECATED ***                  - Status LED now will blink Morse for "A" until the wired-remote link is connected a
             -nd secured.
  70           *                                                                      This needs to be augmented with a retry trap to abort BT connect after 5 or so tries.
  71          ////
  72           *        *** REV 04 ***
  73           *    03-14-20 jmh:  Fixed bug with U16 ISR timers.
  74           *        *** REV 03 ***
  75           *    03-10-20 jmh:  Modified pulse() to accept U16 pulse timer (modified pulse timer also).  Rig array
  76           *                                              still stores U8, so it must be cast when the rig type is read on power-up.
  77           *                                       Modified ICOM mode to use MR(TUNER) as scan up, and F-1(V/M) as scan down.  These
  78           *                                              keys instantiate an 800ms pulse on up or dn to start the scan mode.
  79           *                                       Modified ICOM pulse period to 45 ms (was 40).
  80           *                                       Added named rig types for Kenwood and generic 100 and 125.
  81           *                                       Fixed several code snippets for "VERS == 1" build case.
  82           *        *** REV 02 ***
  83           *    08-28-19 jmh:  Debug of HM151 mode.  Tested on IC-7000.  Found that the first key is ignored if no
  84           *                                              other keys are detected after.  This means that the F-2 key needn't be set to a
  85           *                                              null command (can't do this anyway).  Also verified that HM-151 keys are active
  86           *                                              during TX.
  87           *                                       Modified code to trap leading and falling edge of 'G' key.  If entering pass-thru
  88           *                                              mode, delay DMUTE switch until release of 'G', else switch DMUTE immediately.
  89           *                                       Revamped init code to make sure DMUTE is not set to pass-thru until just before the
  90           *                                              start of the MPL.
  91           *                                       Added timer clear statements to init code to cover warm start case.
  92           *        08-19-19 jmh:  Added pulse delay variable to radio_fbtn[][] array.  Kenwood needs at least 80ms,
  93           *                                              ICOM can take 40ms.  Other delays up to 125 are also included.
  94           *                                       HW MOD: changed comparator voltage ref to a voltage divider driven from M8V to
  95           *                                              follow what the radios do.
  96           *                                       HW MOD: changed how 5V is wired to reset circuit.  Debug adapter now works at
  97           *                                              least as well as with the 3.3V bypass Vreg.
  98           *        08-18-19 jmh:  VERS 2 testing continues...
  99           *                                       Tested HM151 mode & corrected LED functions.  *** Need to test with IC-7000.
 100           *                                       Abandoned SPR as a strap, made Ro3 3rd strap.
 101           *                                       *** need to test option straps.
 102           *        08-17-19 jmh:  VERS 2 initial bring-up complete.  Issues:
 103           *                                              1) The dual FET footprint was wrong.  Had to re-map 4094 bitmap to correct.
 104           *                                                      LED and DMUTE had to be re-wired, so no SW change for those signals.
 105           *                                                      PCB rev 003 update complete.  Added Ro3 "gimmick" resistor to make P0.6
 106           *                                                      the 3rd strap option.  *** Need to see if this works. ***
 107           *                                              2) Voltage reg either broke or some configuration issue.
 108           *                                                      Flaky debug and operation modes - will look again at this on 2nd build.
 109           *                                                      1st article has a 3V regulator piggy-backed on the 5V Vreg with a jumper to
 110           *                                                      U2 Vdd net (Vregi pin is lifted).  U5 Vhi is about 2.9V...not sure this
 111           *                                                      can be counted on to work all the time.
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 3   

 112           *                                       Made some code tweaks to get DTMFs to work correctly.  Not sure why they broke going
 113           *                                              to rev 002 HW.  Also, cleaned up some commented-out code (still some left).
 114           *                                       Added "mic present" mirror.  If strap selects HM151, DN0 = MIC_DET_N any time MIC_DET_N
 115           *                                              changes state.  In addition to mirror, this code kills PTT and tone related registers
 116           *                                              and clears DMUTE if the mic is removed.
 117           *                                              Added restart capability to re-initialize system when mic is removed.  Code will
 118           *                                              continually restart until mic is re-connected.
 119           *                                       Resticted all keys but "M" in HM151 mode.  DTMFs will generate if PTT pressed & DMUTE
 120           *                                              is active.
 121           *        08-15-19 jmh:  HM133 DTMF now works (mostly).  PTT can NOT be pressed if HM133 DTMF-S is active.
 122           *                                              May not need HM133/HM151 strap-opt.
 123           *                                       Strap support for revA *mostly* working.
 124           *                                       1st key logic now traps "1st" 1st key and ignores following until button released.
 125           *        08-12-19 jmh:  Added support for straps.  radio_fbtn[][] array holds transistor pulse patterns that
 126           *                                              correspond to key/rig combinations.
 127           *                                       Added support for extended buttons (MC-44/MH-36) in the button operations switch{} and
 128           *                                              in the support Fns.
 129           *                                       Changed pulse_up/pulse_dn to a single funtion which now supports all of the transistor
 130           *                                              outputs of the CD4094 SR port expander.
 131           *                                       VERS 1 now support using DMUTE for a single expansion button (since it won't do the
 132           *                                              HM151 FT option correctly).
 133           *                                       Added support for HM151 FT mode.  Fn LED = off if in FT mode, else, on for DTMF enabled mode.
 134           *    08-09-19 jmh:  Added #if directives to support PCB version 2.  Re-mapped PTT, UP, and DN bit control
             -s
 135           *                                              to use a central Fn to set/clear bits.  Paves the way for port extender to be used
 136           *                                              in version 2 PCB.  bbSPI code is in place for port expander.  Waveforms verified on
 137           *                                              o'scope, but not tested.  Port update uses TIMER0 ISR to clock 8 bits and strobe
 138           *                                              CD4094 port expander I.C..  XFR plus STB takes about 45us.
 139           *        08-07-19 jmh:  Added feature to interrupt U/D macros on any keypress
 140           *                                       Added feature to change Fn LED brightness.  If no PTT, "*" = dim, "#" = brt.
 141           *
 142           *    08-04-19 jmh:  basic functionality working with HM-151.  HM-133 DTMFs need work.
 143           *                                       added a DTMF activity timer for HM-151 so that the MIC is unmuted
 144           *                                              after an interval of no DTMF key being pressed.
 145           *                                       The "Fn LED" now depicts mic mute status during tone cycles.  Off =
 146           *                                              muted (or macro digit pressed), ON = unmuted.  Blink = up/dn pulse.
 147           *
 148           *        *** REV 01 ***
 149           *        08-03-19 jmh:  project baselined at rev 01
 150           *    07-20-19 jmh:  Project origin, copied from Orion PLL
 151           *
 152           ***************************************************************************************/
 153          
 154          /****************************************************************************************
 155           *  File scope revision history:
 156           *  06-26-22 jmh:   modified to support wired-remote control head interface 
 157           *  04-09-16 jmh:       creation date
 158           *
 159           ***************************************************************************************/
 160          
 161          //--------------------------------------------------------------------------------------
 162          // main.c
 163          //
 164          //      The following resources of the F531 are used:
 165          //      24.500 MHz internal osc
 166          //
 167          //      UART: RDU command output
 168          //
 169          //      Timer0: bbSPI clock driver
 170          //      Timer1: UART baud clock
 171          //      Timer2: DDS sample driver (23.925 KHz) & Application timer (1ms/tic)
 172          //
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 4   

 173          //      ADC: n/u
 174          //
 175          //      PCA: 
 176          //                       CEX0 = ICOM mic data decode ISR
 177          //                       CEX1 = tone DDS PWM
 178          //                       CEX2 = Aux LED PWM out (Fixed PWM ratio, no ISR)
 179          //
 180          //      SYSTEM NOTES:
 181          //
 182          //              This project adapts an HM-133 (or HM-151) microphone so that it can produce DTMF signals.
 183          //              The PCB features the F531 MCU, a 3.3V regulator, open-drain drivers for up/dn and PTT, and
 184          //              switching circuits for the microphone/DTMF signals.  The small form-factor board is intended
 185          //              to be an in-line module between the microphone and the transciever.  Additional features
 186          //              such as up/down toggle commands are also possible allowing a specific number of pulses (up or
 187          //              dn) to be issued to the connected radio.  DTMF memories are also possible using spare FLASH
 188          //              to hold the sequences.
 189          //
 190          //              DTMF signals are generated using DDS code running the PCA CEX1 output in 8-bit PWM mode.  If
 191          //              a keypress is recieved while the PTT is active (from either the PTT input discrete or the PTT
 192          //              keycode), the system will turn on the appropriate DTMF pair until the key is released, or PTT
 193          //              goes inactive.  Since PCA can't do an 8-bit regular interrupt, Timer2 is used to drive the sample
 194          //              clock.  Thus, the DDS ISR code lives inside Timer2, and updates the PWM register.  Timer2 needs to
 195          //              run at the same rate as the PCA to preserve update alignment.
 196          //
 197          //              The DDS is currently being driven at FSAMP = 23,925 Hz to ease the filtering requirements.  This
 198          //              increases the Fstep to 0.365Hz, but this is still well below the worst-case 10.4Hz ETSI requirement
 199          //              for DTMF.
 200          //
 201          //              PCA CEX2 is used to drive an "AUX" LED on the HM-133 (typically blue, and is user installed near
 202          //              the u/d buttons on the HM-133/151).  It is a fixed PWM output to provide a fine adjustment to the
 203          //              LED brightness.  LED on/off/brightness can be used to convey status (power on, DTMF output, PGM
 204          //              mode enabled, etc...).
 205          //
 206          //              The software also interprets HM-133 key codes to drive the PTT and U/D open-drain discretes.
 207          //              U/D also features a tiered pulse ramp whereby the initial keypress sends one pulse, then after
 208          //              1 second of holding, the system begins pulsing at 5 Hz.  After 3 seconds of keypress, the
 209          //              system begins pulsing at 10 Hz.  Pulsing stops imeediately upon release of the key.
 210          //
 211          //              This is the "non" wired-remote SW version which uses a direct connection from TXD to the target RDU
 212          //              to transfer keypress messages at 115200 baud.
 213          //              HM-133 TX commands are 5-bytes long: <'~'><cmd><d/u/h><chk><\r>
 214          //                              <'~'> is fixed preamble
 215          //                              <cmd> is a single-byte alpha-numeric key ID command
 216          //                              <p/r/h> is a single character for key (p)ress, (r)elease, or (h)old
 217          //                              <chk> = (<cmd> EOR <p/r/h>) OR 0x80
 218          //                              <\r> is <CR>, ASCII 0x0d
 219          //
 220          //              First, send "p" param.  As long as key is held, send "h" param at 500ms rate.  Send "r" param as soon
 221          //              as key is released.
 222          //
 223          //--------------------------------------------------------------------------------------
 224          
 225          //-----------------------------------------------------------------------------
 226          // Includes
 227          //-----------------------------------------------------------------------------
 228          // compile defines
 229          #include "init.h"
 230          #include "typedef.h"
 231          #include "c8051F520.h"
 232          #include "serial.h"
 233          #include "wired_rmt.h"
 234          
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 5   

 235          //-----------------------------------------------------------------------------
 236          // Definitions
 237          //-----------------------------------------------------------------------------
 238          
 239          #define DBUG    0
 240          
 241          // DEPRECATED... THIS SW DOESN'T SUPPORT VERS == 2
 242          //#define       VERS    1                               // PCB vers 2 uses 4094 port expander, else VERS = 1
 243                                                                          // !! IC-901 expander code (this project) is currently only valid for VERS = 1 !!
 244          
 245          //#define       IS_SIM                          // enable this define if using simulator
 246          
 247          //  see init.h for #defines
 248          
 249          
 250          //-----------------------------------------------------------------------------
 251          // External Variables
 252          //-----------------------------------------------------------------------------
 253          
 254          extern code const U8    SINE[];
 255          idata volatile  U16             hmd_timer;                                              // HM151 data idle timeout timer
 256          
 257          //-----------------------------------------------------------------------------
 258          // Main Variables
 259          //-----------------------------------------------------------------------------
 260          
 261          // port assignments
 262          
 263          // PCB version 1 bit defines
 264          sbit MDATA              = P1^7;                         // (a) mic data in
 265          sbit MMUTE_N    = P1^6;                         // (o) mic mute out (act low)
 266          sbit PTTb               = P1^5;                         // (o) PTT out to rig (act hi)
 267          sbit DNb            = P1^4;                             // (o) mic DN button out to rig (act hi)
 268          sbit UPb            = P1^3;                             // (o) mic UP button out to rig (act hi)
 269          sbit CMP_IN             = P1^2;                         // (a) comparator (+) input (VREF with hysteresis)
 270          sbit PTTM_N     = P1^1;                         // (i) mic PTT in (act low)
 271          sbit DMUTE              = P1^0;                         // (o) rig data mute out (act hi)
 272          
 273          
 274          sbit PTT_CALL   = P0^6;                         // (i) PTT/CALL enable (if GND)
 275          sbit MDATA_IN   = P0^2;                         // (i) limited serial data input (connected to comparator out)
 276          
 277          
 278          //-----------------------------------------------------------------------------
 279          // Local variables
 280          //-----------------------------------------------------------------------------
 281          #define HM_START        0x01
 282          #define HM_ERROR        0x02
 283          #define HM_BUFMAX       4                                                               // HM-133/151 buffers and working regs
 284                          volatile        U8              hm_hptr;                                                // save ptr in case we overflow
 285                          volatile        U8              hm_tptr;                                                // HM-133/151 key buffer tail ptr
 286          idata   volatile        U32             hm_buf[HM_BUFMAX];
 287                          volatile        U8              hm_status_buf[HM_BUFMAX];
 288                          volatile        U8              hm_ctptr;                                               // capture buf tail ptr
 289                          volatile        U8              hm_chptr;                                               // capture buf head ptr
 290          idata   volatile        U32             sys_error_flags;                                // system error flags
 291          idata   volatile        char    curr_key;
 292          
 293                          volatile        U8              ipldds;                                                 // dds ISR init flag
 294                          volatile        U16             delF1;                                                  // phase (tone) register for tone 1
 295                          volatile        U16             delF2;                                                  // phase (tone) register for tone 2
 296          
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 6   

 297                          volatile        U8              t2pscl;                                                 // t2 prescaler
 298                          volatile        U16             hmkey_timer;                                    // key timer
 299                                                  U8              hmkey_timer_flag;
 300                          volatile        U8              waittimer;                              // wait() function timer
 301                          volatile        U8              dbounceHM_tmr;
 302                          volatile        U8              iplTMR;                                     // timer IPL init flag
 303                          volatile        U16             press_timer;                                    // key press timer and flag
 304                          volatile        U8              press_flag;                                             // key-press timeout flag
 305                                                  U16             pulse_delay;                                    // pulse delay value
 306          #define UD_PERIOD       10                                                              // up/dn pulse period
 307                          volatile        U16             ud_timer;
 308                                                  U8              ud_timer_flag;
 309                          volatile        bit             wr_flag;
 310                          volatile        U16             wr_timer;
 311                          volatile        bit             wra_flag;
 312                          volatile        U16             wra_timer;
 313                          volatile        U8              xport;                                                  // expansion port data register
 314          
 315          // bbSPI registers
 316                          volatile        U8              spdr;
 317                          volatile        U8              spmask;
 318          
 319          // HM133/151 ISR data decode vars
 320          idata   volatile        U32     dmask;                                                          // data mask
 321          idata   volatile        U32     hm_data;                                                        // data register
 322                          volatile        U8      hm_status;                                                      // status register
 323                          volatile        U16     last_edge;                                                      // last edge capture (sign extended to 32 bits)
 324                          volatile        U8      bit_count;                                                      // count of # bits rcvd
 325          
 326          // HM-133/151 code LUT arrays:
 327          #define MAX_KEY 25                                                                      // # keys on HM-151
 328          #define MAX_KEY_133     23                                                              // # keys on HM-133
 329          
 330          //      HM-133: there are actually 25 keys, but two of them act as modifiers
 331          //        (func and dtmf) and do not send a key code.  The keys have different
 332          //        labeling, but each key is in roughly the same position with the same
 333          //        code.  However, many keys are labeled differently from the HM-151.
 334          //        HM-133 applications should use the following key map:
 335          //              Key code        Function (key)                                          HM-151 function (key)
 336          //                M                     F2                                                                      MR
 337          //                V                     F1                                                                      V/M
 338          //                X                     Band change                                                     XFC
 339          //                T                     MR (and MW with persistent press)       TUNER/CALL
 340          //                L                     VFO                                                                     SPCH/LOCK
 341          //                F                     n/a                                                                     F1
 342          //                G                     n/a                                                                     F2
 343          //
 344          // HM-133 function key return set.  '%' and '!' are placekeepers to keep
 345          //      alignment with the key_addr[] array.  These codes should never be sent
 346          //      by an HM-133.  HM-151 doesn't have a FUNC mode, so it will never send
 347          //      any of these codes.
 348          // !! These codes don't mean anything to the adapter, so they are included as comments
 349          //      for completeness. !!
 350          code char fnkey_code[] = { 'p',   'o',   'n',   'k',   'm',   'l',   'j',  '|',
 351                                                    '!',   'a',   'b',   'c',   'q',   'd',   'e',   'f',
 352                                                    'r',   'g',   'h',   'i',   's',   '+',   '`',   '$',
 353                                                    't',   '\0' };
 354          // Normal mode keycodes for HM-151 and HM-133 (see above for HM-133 notes)
 355          code char key_code[] = { 'L',   'T',   'X',   '/',   'V',   'M',   '\\',  'F',
 356                                                  'G',   '1',   '2',   '3',   'A',   '4',   '5',   '6',
 357                                                  'B',   '7',   '8',   '9',   'C',   '*',   '0',   '#',
 358                                                  'D',   '\0' };
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 7   

 359          
 360          #define DTMF_OFFS       (9)             // offset to subtract from key_code index to become dtmf index
 361                                                                  // this offset is dependent on the placement of keycodes in the
 362                                                                  // "_code" tables above.  SO...don't re-arrange the key_code[] table!
 363          
 364          // DTMF tone lookup tables for row and column
 365          code U16 dtmf_row[] = { ROW1_TONE, ROW1_TONE, ROW1_TONE, ROW1_TONE,
 366                                                      ROW2_TONE, ROW2_TONE, ROW2_TONE, ROW2_TONE,
 367                                                      ROW3_TONE, ROW3_TONE, ROW3_TONE, ROW3_TONE,
 368                                                      ROW4_TONE, ROW4_TONE, ROW4_TONE, ROW4_TONE,
 369                                                    };
 370          code U16 dtmf_col[] = { COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 371                                                      COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 372                                                      COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 373                                                      COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 374                                                    };
 375          // serial key codes less the func/dtmf/1stkey modifier nybble.
 376          code U16 fnkey_addr[] =  {0x0b42,0x1342,0x2342,0x2242,0x0a42,0x1242,0x2042,0x1042,
 377                                             0x0842,0x0bc2,0x13c2,0x23c2,0x43c2,0x09c2,0x11c2,0x21c2,
 378                                             0x41c2,0x0ac2,0x12c2,0x22c2,0x42c2,0x08c2,0x10c2,0x20c2,
 379                                             0x40c2,0x0000};
 380          
 381          code U16 key_addr[] =  {0x0b02,0x1302,0x2302,0x2202,0x0a02,0x1202,0x2002,0x1002,
 382                                             0x0802,0x0b82,0x1382,0x2382,0x4382,0x0982,0x1182,0x2182,
 383                                             0x4182,0x0a82,0x1282,0x2282,0x4282,0x0882,0x1082,0x2082,
 384                                             0x4082,0x0000};
 385          
 386          // The first index selects the radio type, the second index selects the button.
 387          //      The array return is written to the port expansion SR to select the desired Fn.
 388          code U8 radio_fbtn[] = { UP, UP1,      UP2,         DN, DN1,          DN2,      MS45};          // 0    generic (ICOM
             -)
 389          //              HM133 button -->        UP  F1        VFO/LOCK     DN  MR/CALL       BAND/OPT   Pulse Delay
 390          //                                                      |   |         |            |   |             |                  |
 391          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,      MS45},               // 0    generic (ICOM)
 392          //                                                { UP, MH36_ACC, MH36_P1,     DN, MH36_DMR,     MH36_P2, MS100},               // 1    Yaesu MH36
 393          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,      MS80},               // 2    Kenwood
 394          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS100},               // 3    generic (ICOM/KW) <- place
             -keeper for new rig type
 395          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS125},               // 4    generic (ICOM/KW) <- place
             -keeper for new rig type
 396          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS125},               // 5    generic (ICOM/KW) <- place
             -keeper for new rig type
 397          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS125},               // 6    generic (ICOM/KW) <- place
             -keeper for new rig type
 398          //                                                { 0,    0,        0,          0,   0,            0,         0}                // 7    HM-151 (IC-7000) -- no up/d
             -n or other outputs supported
 399          //                                            };                                                                                                                                        //              for this mic
 400          
 401          code U8 swopt_pattern_lut[] = {
 402                  // "a" = 00000001, mask = 00000010
 403                  0x01,
 404                  // "b" = 00001000, mask = 00001000
 405                  0x08,
 406                  // "c" = 00001010, mask = 00001000
 407                  0x0a,
 408                  // "d" = 00000100, mask = 00000100
 409                  0x04,
 410                  // "e" = 00000000, mask = 00000001
 411                  0x00,
 412                  // "f" = 00000010, mask = 00001000
 413                  0x02,
 414                  // "g" = 00000110, mask = 00000100
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 8   

 415                  0x06,
 416                  // "h" = 00000000, mask = 00001000
 417                  0x00 };
 418          
 419          code U8 swopt_mask_lut[] = {
 420                  // "a" = 00000001, mask = 00000010
 421                  0x02,
 422                  // "b" = 00000001, mask = 00001000
 423                  0x08,
 424                  // "c" = 00000101, mask = 00001000
 425                  0x08,
 426                  // "d" = 00000100, mask = 00000100
 427                  0x04,
 428                  // "e" = 00000000, mask = 00000001
 429                  0x01,
 430                  // "f" = 00000010, mask = 00001000
 431                  0x08,
 432                  // "g" = 00000110, mask = 00000100
 433                  0x04,
 434                  // "h" = 00000000, mask = 00001000
 435                  0x08 };
 436          
 437          //-----------------------------------------------------------------------------
 438          // Local Prototypes
 439          //-----------------------------------------------------------------------------
 440          
 441          void process_hm(U8 flag);
 442          void flash_swvers(U8 pattern, U8 mask);
 443          void pulse(U8 discr, U8 pcount, U16 pdly);
 444          void outbit(U8 bitmap, U8 on);
 445          void send8(U8 sdata);
 446          U8 get_opt(void);
 447          U8 got_hmd(void);
 448          S32 get_hmd(void);
 449          char* get_hmcode(U32 keym);
 450          void put_hmcode(U32 keym);
 451          
 452          //******************************************************************************
 453          // main()
 454          //  The main function inits I/O and process I/O.
 455          //
 456          //******************************************************************************
 457          void main(void) //using 0
 458          {
 459   1      idata   volatile U8             i;                              // temp uchar
 460   1      idata   volatile U8             j;
 461   1      static  idata    U8             q;                              // DTMF-S temp
 462   1      static  idata    U8             t;                              // DTMF-S temp
 463   1      static                   bit    mdet_edge;              // mic det edge reg
 464   1      static  data     U8             new_events;
 465   1      //static        data     U8             dmute_mem;              // reg to hold initial dmute status when "G" key detected
 466   1      idata volatile char             d;                              // temp char
 467   1      static            char*         dp;                             // pointer to key code array
 468   1      #define MAX_ACCUM       99
 469   1      idata   volatile U8             accum;                  // u/d pulse-count accumulator
 470   1      static  data    U32             si;                             // temp 32
 471   1      static  idata    U8             hm_count;               // hm key repeat counter
 472   1      static  idata    U8             keyh_mem;               // current key (used to determine 1st keypress)
 473   1      static                  bit             keyh_edg;               // 1st key edge
 474   1      static                  bit             ptt_edge;               // edge discrete
 475   1      static                  bit             aflag;                  // accum repeat inhib flag
 476   1      static  data     U8             softptt;                // soft ptt detected
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 9   

 477   1      //data  volatile U8             swopt;                  // SW ipl strap options
 478   1                      volatile U8             run;                    // warm restart trigger
 479   1      
 480   1              // start of main
 481   1              while(1){                                                                       // outer loop is for soft-restart capability
 482   2                      PCA0MD = 0x00;                                                  // disable watchdog
 483   2                      EA = 0;
 484   2                      // init MCU system
 485   2                      Init_Device();                                                  // init MCU
 486   2                      t2pscl = T2_MS1PS;                                              // init prescaler
 487   2                      EA = 1;
 488   2                      xport = 0;                                                              // init expansion port
 489   2                      // VERS 1 port init
 490   2                      PTTb = 0;                                                               // (o) PTT out to rig (act hi)
 491   2                      DNb = 1;                                                                // (o) mic DN button out to rig (act hi)
 492   2                      UPb = 0;                                                                // (o) mic UP button out to rig (act hi)
 493   2                      DMUTE = 0;                                                              // (o) rig data mute out (act hi)
 494   2                      MDATA_IN = 1;                                                   // (i) mic data in
 495   2                      MDATA = 1;
 496   2                      CMP_IN = 1;
 497   2                      PTT_CALL = 1;
 498   2                      init_serial();
 499   2                      pulse_delay = (U16)radio_fbtn[IDX_PLSDLY]; // fetch pulse delay
 500   2                      MDATA = 1;
 501   2                      MMUTE_N = UNMUTE_BIT;                                   // (o) mic mute out (act low)
 502   2                      PTTM_N = 1;                                                             // (i) mic PTT in (act low)
 503   2                      DMUTE = 1;                                                              // (o) rig data mute out (act hi)
 504   2                      // init module vars
 505   2                      iplTMR = TMRIPL;                        // timer IPL init flag
 506   2                      PCA0CPM1 &= 0xfe;                                               // disable CCF1
 507   2                      dmask = 0x01;                                                   // reset data regs
 508   2                      hm_data = 0;
 509   2                      bit_count = 0;
 510   2                      hm_status = 0;
 511   2                      last_edge = 0;
 512   2                      keyh_edg = 0;
 513   2                      delF1 = 0;                                                              // cler the DDS tone regs
 514   2                      delF2 = 0;
 515   2                      hmkey_timer = 0;
 516   2                      waittimer = 0;
 517   2                      dbounceHM_tmr = 0;
 518   2                      press_timer = 0;
 519   2                      press_flag = 0;
 520   2                      ud_timer = 0;
 521   2                      accum = 0;
 522   2                      ipldds = 1;                                                             // ipl the DDS
 523   2      //              init_serial();                                                  // init UART
 524   2                      // process IPL init
 525   2                      keyh_mem = KEY_NULL;
 526   2                      hm_count = 0;
 527   2                      aflag = 0;
 528   2                      softptt = 0;                                                    // init soft PTT
 529   2                      mdet_edge = 1;
 530   2      
 531   2                      #ifndef IS_SIM                                                  // skip DDS wait for sim
 532   2                      while(ipldds);                                                  // wait for DDS to init
 533   2                      #endif
 534   2                      
 535   2                      #ifdef  IS_SIM                                                  // allows range-checking of big constants in simulator
                              delF1 = HMT_SYNC;                                               // place constant expressions here for a quick check
                              delF1 = COL4_TONE;
                              #endif
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 10  

 539   2      
 540   2                      // serial debug version msg
 541   2      //              putss("IC901RCH VR4\n\r");
 542   2                      i = RSTSRC;
 543   2                      putch('~');
 544   2                      putch(hiasc(i));
 545   2                      putch(lowasc(i));
 546   2                      putch('\r');
 547   2      
 548   2                      // flash version (R4) and radio select code:
 549   2                      //       "R" = 00000010 = 0x02          mask = 00000100 = 0x04
 550   2                      flash_swvers(0x02, 0x04);
 551   2                      //       "4" = 00000001 = 0x01          mask = 00010000 = 0x10
 552   2                      flash_swvers(0x01, 0x10);
 553   2                      DMUTE = 1;                                                              // inhibit pass-thru
 554   2                      PCA0CPM2 |= 0x40;                                               // fn led on (ECOM);
 555   2                      ptt_edge = ~PTTM_N;
 556   2                      process_WR(STATE_INIT);                                 // init wired-remote process
 557   2                      run = 1;                                                                // enable run
 558   2                      wait(2);
 559   2                      // main loop
 560   2                      while(run){                                                                                                     // inner-loop runs the main application
 561   3                              process_WR(K_NULL);                                                                             // process hold timer                                                   
 562   3                              new_events = 0;
 563   3                              d = PTTM_N;
 564   3                              if(d != ptt_edge){                                                                              // process manual PTT input
 565   4      //                              if(!PTT_CALL){
 566   4      //                                      process_WR(SMUTE);                                                              // toggle smute button on PTT edge if P0.6 == GND
 567   4      //                              }
 568   4                                      ptt_edge = d;
 569   4                                      if(d){                                                                                          // PTT input is ground true
 570   5                                              MMUTE_N = MUTE_BIT;                                                             // PTT released
 571   5                                              outbit(PTT, 0);
 572   5                                              delF1 = 0;
 573   5                                              delF2 = 0;
 574   5                                              PCA0CPM2 |= 0x40;                                                               // fn led on (ECOM);
 575   5                                              // turn off PWMO ISR
 576   5                                              PCA0CPM1 &= 0xfe;
 577   5                                      }else{
 578   5                                              outbit(PTT, 1);                                                                 // PTT pressed
 579   5                                              MMUTE_N = UNMUTE_BIT;
 580   5                                      }
 581   4                              }
 582   3      
 583   3                              if(got_hmd()){                                                                                  // trap keys
 584   4                                      new_events = KEYHM_CHNG;
 585   4                                      dbounceHM_tmr = HM_DEBOUNCE;
 586   4                              }
 587   3                              if(dbounceHM_tmr == 0){
 588   4                                      if(keyh_mem != KEY_NULL){                                                       // trap debounce timeouts
 589   5                                              new_events |= KEYHM_CHNG;
 590   5                                      }
 591   4                              }
 592   3                              if(delF1){
 593   4                                      press_timer = MS1650;                                                           // reset DTMF timer anytime a tone is being generated
 594   4                              }
 595   3                              if(press_flag){                                                                                 // keypress timeout, enable mic
 596   4                                      if(d){                                                                                          // if no GPIO PTT, unkey
 597   5                                              outbit(PTT, 0);
 598   5                                      }
 599   4                                      press_flag = 0;
 600   4                                      PCA0CPM2 |= 0x40;                                                                       // fn led back on (ECOM);
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 11  

 601   4                                      MMUTE_N = UNMUTE_BIT;                                                           // unmute mic
 602   4                              }
 603   3                              d = '\0';
 604   3                              // this branch handles key-driven events
 605   3                              if(new_events & KEYHM_CHNG){                                                    // process trapped events
 606   4                                      if(!softptt){
 607   5                                              if(dbounceHM_tmr == 0){                                                 // process no-key from HM-133/151
 608   6                                                      keyh_edg = 0;
 609   6                                                      if(keyh_mem != KEY_NULL){
 610   7                                                              // release key
 611   7                                                              if(!delF1){
 612   8                                                                      PCA0CPM2 |= 0x40;                                       // led back on if no tone (ECOM);
 613   8                                                              }
 614   7                                                              aflag = 0;                                                              // release accum inhibit
 615   7                                                              i = 0;                                                                  // set release keypress
 616   7                                                              i = keyh_mem | 0x80;                                    // set release keypress
 617   7      //                                                      process_WR(K_REL);                                              // release key to remote host
 618   7                                                      }
 619   6                                                      keyh_mem = KEY_NULL;                                            // if no key, clear current key mem.
 620   6                                              }
 621   5                                      }
 622   4                                      si = get_hmd();                                                                         // get hm-133/151 data word
 623   4                                      dp = get_hmcode(si);                                                            // do key-code lookup, pointer is set to keycode array
 624   4      #if DBUG == 1
                                              put_hmcode(si);                 // DEBUG !!!
              #endif
 627   4                                      d = *(dp + HM_IDX_CODE);
 628   4      
 629   4                                      if(*(dp + HM_IDX_STAT) & HM_1STKEY){
 630   5                                              if(keyh_edg == 0){
 631   6                                                      keyh_edg = 1;
 632   6                                              }else{
 633   6                                                      *(dp + HM_IDX_STAT) &= ~HM_1STKEY;                      // only allow 1 1stkey in a row
 634   6                                              }
 635   5                                      }else{
 636   5                                              keyh_edg = 0;
 637   5                                      }
 638   4      
 639   4                                      if(d != KEY_NULL){                                                                      // trap first press, and prevent false repeats
 640   5                                              if(d == PTT_CODE){
 641   6                                                      i = d;
 642   6                                                      keyh_mem = KEY_NULL;
 643   6                                              }else{
 644   6                                                      dbounceHM_tmr = HM_DEBOUNCE;                            // reset loss-of-key detect timer
 645   6                                                      if(d && (d != keyh_mem)){                                       // if mic data is not null AND key mem is null:
 646   7                                                              keyh_mem = d;                                                   // save key to mem (first key)
 647   7                                                              i = d;
 648   7                                                      }else{
 649   7                                                              // process hold message
 650   7                                                              process_WR(K_HOLD);
 651   7                                                      }
 652   6                                              }
 653   5                                      }else{
 654   5                                              keyh_edg = 0;                                                                   // save null to key mem if debounce == 0
 655   5                                      }
 656   4                                      if(i & 0x80){
 657   5                                              delF1 = 0;
 658   5                                              delF2 = 0;
 659   5                                      }
 660   4                                      // process DTMF keys if PTT == 1, or send to remote host if PTT == 0
 661   4                                      if(((i>='0') && (i<='9')) || ((i>='A') && (i<='D')) || (i =='*') || (i == '#')){
 662   5                                              t = 1;
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 12  

 663   5                                      }else{
 664   5                                              t = 0;
 665   5                                      }
 666   4                                      j = *(dp + HM_IDX_STAT) & HM_1STKEY;
 667   4                                      if(*(dp + HM_IDX_STAT) & (HM_PTT | HM_DTMF) == (HM_PTT | HM_DTMF) && !t){
 668   5                                              // DTMF-S PTT hold
 669   5                                              q = 1;
 670   5                                              delF1 = 0;
 671   5                                              delF2 = 0;
 672   5                                      }
 673   4              /*                      if(((*(dp + HM_IDX_STAT) & HM_PTT) == HM_PTT) && q){
 674   4                                              // DTMF-S release
 675   4                                              q = 0;
 676   4                                              MMUTE_N = UNMUTE_BIT;                                                   // (o) mic unmute out (act low)
 677   4                                      }*/
 678   4                                      if(t){
 679   5                                              if(*(dp + HM_IDX_STAT) & HM_DTMF){
 680   6                                                      press_timer = MS1650;                                           // reset DTMF timer
 681   6                                              }
 682   5                                              if(*(dp + HM_IDX_STAT) & HM_PTT){
 683   6                                                      outbit(PTT, 1);
 684   6                                              }
 685   5                                              if(xport & PTT){
 686   6                                                      if(j){
 687   7                                                              PCA0CPM2 &= ~0x40;                                              // fn led off if dtmf (ECOM);
 688   7                                                              MMUTE_N = MUTE_BIT;                                             // (o) mic mute out (act low)
 689   7                                                              delF1 = dtmf_row[*(dp+HM_IDX_DTMF)];
 690   7                                                              delF2 = dtmf_col[*(dp+HM_IDX_DTMF)];
 691   7                                                      }
 692   6                                              }else{
 693   6                                                      // the chrs between '9' and 'A' are not possible, so they are included to simplify the code
 694   6                                                      if(((i >= '0') && (i <= 'D')) || (i == '*') || (i == '#')){     // send digit sub-matrix to remote host
 695   7                                                              process_WR(i);                                                  // send digit message                                                   
 696   7                                                      }
 697   6                                              }
 698   5                                      }else{
 699   5      //                                      process_WR(i);                                                  // send button message
 700   5                                              if((i > '@') && (i < 'z')) j = 1;
 701   5                                              else j = i;
 702   5                                              switch(j){
 703   6                                                      // process top function buttons (non-dtmf)
 704   6                                                      case '/':
 705   6                                                      case '|':
 706   6                                                      case '!':
 707   6                                                      case '+':
 708   6                                                      case '$':
 709   6                                                      case 1:
 710   6                                                              process_WR(i);                                                  // send digit message                                                   
 711   6                                                              break;
 712   6                                                      
 713   6                                                      default:
 714   6                                                              if(i & 0x80){
 715   7                                                                      process_WR(K_REL);                                      // release key to remote host
 716   7                                                              }
 717   6                                                              break;
 718   6                                              }
 719   5                                      } // end "key processing" branch
 720   4                              } // end "new events"
 721   3                      } // end while(run)
 722   2              } // end outer while()
 723   1      } // end main()
 724          
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 13  

 725          // *********************************************
 726          //  *************** SUBROUTINES ***************
 727          // *********************************************
 728          
 729          //-----------------------------------------------------------------------------
 730          // flash_swvers() uses ms timer to pulse out Morse data on LED
 731          //      "pattern" is dit(0) or dah(1).  1st element is pointed to by "mask"
 732          //              subsequent elements are toward the LSb of pattern (mask is right shifted
 733          //              to reach next element).  When mask == 0, character is done.  There is
 734          //              a DAH delay on entry and exit.
 735          //-----------------------------------------------------------------------------
 736                  
 737          #define MORSE_PER       MS80    // dit period
 738          
 739          void flash_swvers(U8 pattern, U8 mask){
 740   1              idata U8        j = 0;                  // temp vars
 741   1      volatile        U8      k = mask;               // vers pattern temps
 742   1      
 743   1              PCA0CPM2 &= ~0x40;                                                              // led dim (ECOM)
 744   1              ud_timer = (3 * MORSE_PER);
 745   1              ud_timer_flag = TRUE;
 746   1              while(ud_timer_flag);
 747   1              do{
 748   2                      process_WR(0);                                                          // process wired-remote
 749   2                      PCA0CPM2 &= ~0x40;                                                      // led dim (ECOM)
 750   2                      ud_timer = MS100;
 751   2                      ud_timer_flag = TRUE;
 752   2                      while(ud_timer_flag);
 753   2                      PCA0CPM2 |= 0x40;                                                       // led brt (ECOM)
 754   2                      if(pattern & k){
 755   3                              ud_timer = (3 * MORSE_PER);
 756   3                      }else{  
 757   3                              ud_timer = MORSE_PER;
 758   3                      }
 759   2                      ud_timer_flag = TRUE;
 760   2                      k = k >> 1;
 761   2                      process_WR(0);                                                          // process wired-remote
 762   2                      while(ud_timer_flag);
 763   2                      j = got_hmd();
 764   2                      j |= ~PTTM_N;
 765   2              }while((j == 0) && k);
 766   1              if(j == 0){                                                                             // if there was no keypress or ptt, delay
 767   2                      PCA0CPM2 &= ~0x40;                                                      // led dim (ECOM)
 768   2                      ud_timer = (3 * MORSE_PER);
 769   2                      ud_timer_flag = TRUE;
 770   2                      while(ud_timer_flag);
 771   2              }
 772   1              PCA0CPM2 |= 0x40;                                                               // led brt (ECOM)
 773   1              return;
 774   1      }
 775          
 776          //-----------------------------------------------------------------------------
 777          // pulse() uses ms timer to pulse discretes pcount pulses
 778          //-----------------------------------------------------------------------------
 779          /*
 780          void pulse(U8 discr, U8 pcount, U16 pdly){
 781          data    U8      i;              // temp vars
 782          data    U8      j;
 783          
 784                  if(pcount == 0){
 785                          j = 1;
 786                  }else{
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 14  

 787                          j = pcount;
 788                          press_timer = 100;                                                      // set some delay
 789                          press_flag = 0;
 790                          do{
 791                                  i = got_hmd();
 792                                  if(i){
 793                                          get_hmd();                                                      // clear data word buffer
 794                                          press_timer = 80;
 795                                          press_flag = 0;
 796                                  }
 797                          }while(!press_flag);
 798                  }
 799                  for(i=0; i<j; i++){
 800                          PCA0CPM2 &= ~0x40;                                                      // led dim (ECOM)
 801                          outbit(discr, 1);
 802                          ud_timer = pdly;
 803                          ud_timer_flag = TRUE;
 804                          while(ud_timer_flag);
 805                          PCA0CPM2 |= 0x40;                                                       // led brt (ECOM)
 806                          outbit(discr, 0);
 807                          ud_timer = pdly;
 808                          ud_timer_flag = TRUE;
 809                          while(ud_timer_flag);
 810                          if(got_hmd()){
 811                                  i = j;                                                                  // a keypress detected, abort
 812                          }
 813                  }
 814                  return;
 815          }
 816          */
 817          //************************************************************************
 818          // outbit() consolodates OC output port updates into a single function
 819          //************************************************************************
 820          void outbit(U8 bitmap, U8 on){
 821   1              // This is the version 1 routine.  Only PTT, UP, DN, & F2 (MW) are supported
 822   1              switch(bitmap){
 823   2                      case PTT:
 824   2                              if(on){
 825   3                                      PTTb = 1;
 826   3                                      xport |= bitmap;
 827   3                              }else{
 828   3                                      PTTb = 0;
 829   3                                      xport &= ~bitmap;
 830   3                              }
 831   2                              break;
 832   2                      
 833   2                      case UP:
 834   2      //                      if(on) UPb = 1;
 835   2      //                      else UPb = 0;
 836   2                              break;
 837   2                      
 838   2                      case DN:
 839   2      //                      if(on) DNb = 1;
 840   2      //                      else DNb = 0;
 841   2                              break;
 842   2                      
 843   2                      case DN2:
 844   2                              if(on) DMUTE = 1;
 845   2                              else DMUTE = 0;
 846   2                              break;
 847   2                      
 848   2                      default:
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 15  

 849   2                              break;
 850   2              }
 851   1              return;
 852   1      }
 853          
 854          // ******************* HM keypress capture ******************
 855          
 856          //************************************************************************
 857          // wait() waits the U8 value then returns.
 858          //************************************************************************
 859          void wait(U8 wvalue){
 860   1      
 861   1              waittimer = wvalue;                                                             // set the timer
 862   1              while(waittimer);                                                               // wait for it to expire
 863   1              return;
 864   1      }
 865          
 866          //-----------------------------------------------------------------------------
 867          // got_hmd() returns true if HM-133/151 data buffer not empty
 868          //-----------------------------------------------------------------------------
 869          U8 got_hmd(void){
 870   1              bit     rtn = 0;
 871   1      
 872   1              if(hm_tptr != hm_hptr){
 873   2                      rtn = 1;
 874   2              }
 875   1              return (U8)rtn;
 876   1      }
 877          
 878          //-----------------------------------------------------------------------------
 879          // get_hmd() returns HM-133/151 data/status or -1 if no data
 880          //-----------------------------------------------------------------------------
 881          S32 get_hmd(void){
 882   1              idata S32       rtn = -1L;
 883   1      
 884   1              if(hm_tptr != hm_hptr){
 885   2                      rtn = (S32)(hm_buf[hm_tptr] & 0x00ffffff) | ((S32)hm_status_buf[hm_tptr] << 24);
 886   2                      if(++hm_tptr > (HM_BUFMAX-1)) hm_tptr = 0;
 887   2              }
 888   1              return rtn;
 889   1      }
 890          
 891          //-----------------------------------------------------------------------------
 892          // get_hmcode() returns pointer to keycode array
 893          //      1st index is key-data status
 894          //      2nd index is keycode (KEY_NULL if invalid data)
 895          //      3rd index is DTMF tone offset index
 896          //-----------------------------------------------------------------------------
 897          char* get_hmcode(U32 keym){
 898   1              U16             ii;                                     // temps
 899   1              U8              i;
 900   1              U8              di = 0;                         // dtmf index temp
 901   1      static idata char       hm_rtn[3];      // holding array for code and status data
 902   1                                                                      // 0 = stat, 1 = code, 2 = DTMF idx
 903   1      
 904   1              hm_rtn[HM_IDX_CODE] = KEY_NULL;
 905   1              hm_rtn[HM_IDX_STAT] = (U8)keym & 0x0f;                                          // get key status
 906   1              ii = (U16)(keym >> 4);                                                                          // conv hm151/133 keymatrix to keyaddr (low nyb is status)
 907   1              if(ii == 0x0002){                                                                                       // HM-133 PTT
 908   2                      hm_rtn[HM_IDX_CODE] = PTT_CODE;                                                 // semicolon is PTT
 909   2              }else{
 910   2                      if(ii != 0xffff){
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 16  

 911   3                              i = 0;
 912   3                              if(hm_rtn[HM_IDX_STAT] & HM_FNKEY){
 913   4                                      do{
 914   5                                              if(ii == key_addr[i]){  
 915   6                                                      hm_rtn[HM_IDX_CODE] = fnkey_code[i];                    // look for match in fn LUT
 916   6                                                      di = i;
 917   6                                              }
 918   5                                      }while((hm_rtn[HM_IDX_CODE] == KEY_NULL) && fnkey_addr[++i]);   // loop exits when match or end of LUT
 919   4                              }else{
 920   4                                      do{
 921   5                                              if(ii == key_addr[i]){  
 922   6                                                      hm_rtn[HM_IDX_CODE] = key_code[i];                      // look for match in fn LUT
 923   6                                                      di = i;
 924   6                                              }
 925   5                                      }while((hm_rtn[HM_IDX_CODE] == KEY_NULL) && key_addr[++i]);     // loop exits when match or end of LUT
 926   4                              }
 927   3                              if(hm_rtn[HM_IDX_CODE] == KEY_NULL){
 928   4                                      sys_error_flags |= HM_DATA_ERR;
 929   4                              }
 930   3                              if(!(hm_rtn[HM_IDX_STAT] & HM_FNKEY)){
 931   4                                      hm_rtn[HM_IDX_DTMF] = di - DTMF_OFFS;
 932   4                              }
 933   3                      }
 934   2              }
 935   1              return hm_rtn;
 936   1      }
 937          
 938          #if DBUG == 1
              //-----------------------------------------------------------------------------
              // put_hmcode() sends 32b code to UART
              //      !!! FOR DEBUG ONLY !!!
              //-----------------------------------------------------------------------------
              void put_hmcode(U32 keym){
                      U8      i; // temp
              
                      putss("[");
                      i = (U8)(keym >> 24);
                      putch(hiasc(i));
                      putch(lowasc(i));
                      i = (U8)(keym >> 16);
                      putch(hiasc(i));
                      putch(lowasc(i));
                      i = (U8)(keym >> 8);
                      putch(hiasc(i));
                      putch(lowasc(i));
                      i = (U8)(keym);
                      putch(hiasc(i));
                      putch(lowasc(i));
                      putss("]");
                      return;
              }
              #endif
 963          //-----------------------------------------------------------------------------
 964          // wr_timeout() sets or reads the wired remote "key hold" pacing timer
 965          //      if param = 0, return FALSE if timer == 0, else true
 966          //      else, set timer and return
 967          //-----------------------------------------------------------------------------
 968          char wr_timeout(U16 toval){
 969   1              bit     EA_save;
 970   1      
 971   1              if(toval != 0){
 972   2                      EA_save = EA;                                   // prohibit intrpts
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 17  

 973   2                      EA = 0;
 974   2                      wr_timer = toval;
 975   2                      wr_flag = 0;
 976   2                      EA = EA_save;                                   // re-set intrpt enable
 977   2              }
 978   1              return wr_flag;
 979   1      }
 980          
 981          void wr_clr(void){
 982   1              bit     EA_save;
 983   1      
 984   1              EA_save = EA;                                   // prohibit intrpts
 985   1              EA = 0;
 986   1              wr_timer = 0;
 987   1              wr_flag = 0;
 988   1              EA = EA_save;                                   // re-set intrpt enable
 989   1              return;
 990   1      }
 991          
 992          //-----------------------------------------------------------------------------
 993          // wra_timeout() sets or reads the wired remote abort timeout timer
 994          //      if param = 0, return FALSE if timer == 0, else true
 995          //      else, set timer and return
 996          //-----------------------------------------------------------------------------
 997          char wra_timeout(U16 toval){
 998   1              bit     EA_save;
 999   1      
1000   1              if(toval != 0){
1001   2                      EA_save = EA;                                   // prohibit intrpts
1002   2                      EA = 0;
1003   2                      wra_timer = toval;
1004   2                      wra_flag = 0;
1005   2                      EA = EA_save;                                   // re-set intrpt enable
1006   2              }
1007   1              return wra_flag;
1008   1      }
1009          
1010          //-----------------------------------------------------------------------------
1011          // pca_intr
1012          //-----------------------------------------------------------------------------
1013          //
1014          // Called when PCA CEX0 input RE event is detected:
1015          //      This event is rising edge from the HM-151/151 data line.  HM-133/151 data is a
1016          //              serial format that features a 195us low followed by a 230us high
1017          //              (logic "0") or a 415us high (logic "1").  NOTE: The data line is
1018          //              inverted at the input of the MCU (by the comparator).  7 zeros plus a
1019          //              750us low is a sync pulse (start of a 2-word frame)
1020          //
1021          //      HM-151 Keys send bursts of 2 data words at a 43-60 ms rate (measured at
1022          //              about 50 ms on a single device).
1023          //
1024          //      This timer measures the time between rising edges (as seen at MCU pin) and
1025          //              determines if the transitions represent a 1, 0, or sync pulse.  An
1026          //              application timer is used to establish a previous period of no edge
1027          //              activity. (this resets the serial input state machine).
1028          //              The messages are 19 bits plus a stop bit.  Since the timer looks for
1029          //              falling edges, and bursts consist of two words, only the 1st word's
1030          //              stop bit will be captured.  Thus, the first word after a long idle or
1031          //              a sync pulse will count 20 bits until the data is captured.  The 2nd
1032          //              word triggers a capture after only 19 bits.  This saves the expense
1033          //              of configuring another timer ISR to establish the end of the 2nd word's
1034          //              stop bit.
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 18  

1035          //              Once captured, the data word is stored to the FILO buffers (hm_buf[]
1036          //              for data, hm_status_buf[] for status) for processing by the process loops.
1037          //              NOTE: Data consumers must extract both the data and status before
1038          //              updating the tail pointer.
1039          //
1040          //              Keycode matrix:
1041          //              LOCK (L)        TUNER (T)       XFC (X)
1042          //              0b020           13020           23020
1043          //
1044          //              upARROW (/)             V/M (V) MW (M)
1045          //              22020                   0a020   12020
1046          //
1047          //              dnARROW (\)             F1 (F)  F2 (f)
1048          //              20020                   10020   08020
1049          //
1050          //              1               2               3               MODE (A)
1051          //              0b820   13820   23820   43820
1052          //
1053          //              4               5               6               FIL  (B)
1054          //              09820   11820   21820   41820
1055          //
1056          //              7               8               9               GENE (C)
1057          //              0a820   12820   22820   42820
1058          //
1059          //              . (*)   0               CE (#)  ENT  (D)
1060          //              08820   10820   20820   40820
1061          //
1062          //              HM-133:
1063          //              (1) 00002 (1) = PTT pressed
1064          //              (3) 00002 (0) = PTT release
1065          //-----------------------------------------------------------------------------
1066          
1067          void pca_intr(void) interrupt 9 using 2{
1068   1              // HM-133/151 data decode vars
1069   1              U8              temp;                           // temp ptr reg
1070   1              U16             captim;                         // capture time holding reg
1071   1              U16             captemp;                        // capture time temp reg
1072   1              
1073   1          if(CCF0 == 1){
1074   2                              CCF0 = 0;                                                       // clr intr flag
1075   2      
1076   2                              captim = (U16)PCA0L;                                                    // grab time of edge
1077   2                              captim |= ((U16)PCA0H) << 8;
1078   2                              if(captim < last_edge){                                                 // calc pulse duration (in SYSCLK tics)
1079   3                                      captemp = 65535 - last_edge + captim;           // if rollover
1080   3                              }else{
1081   3                                      captemp = captim - last_edge;                           // normal timer progression
1082   3                              }
1083   2                              if(captemp < HMT_MIN) return;                                   // ignore if pulse too short
1084   2                              last_edge = captim;                                                             // save new edge
1085   2                              if(hmd_timer == 0){                                                             // look for LOS timeout
1086   3                                      // reset data & mask
1087   3                                      dmask = 0x01;                                                           // reset data/status regs
1088   3                                      bit_count = 0;
1089   3                                      hm_data = 0;
1090   3                                      hm_status = 0;
1091   3                                      hmd_timer = HMD_BURST_TO;                                       // reset burst timer
1092   3                              }else{
1093   3                                      hmd_timer = HMD_BURST_TO;                                       // reset 5ms timer
1094   3                                      if(captemp < HMT_0){                                            // check if pulse is a "0"
1095   4                                              dmask = dmask << 1;                                             // shift dmask...0 in data is implicit
1096   4                                              bit_count++;                                                    // update bit count
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 19  

1097   4                                      }else{
1098   4                                              if(captemp < HMT_1){                                    // check if pulse is a "1"
1099   5                                                      hm_data |= dmask;                                       // place a "1" into the data reg
1100   5                                                      dmask = dmask << 1;                                     // shift dmask
1101   5                                                      bit_count++;                                            // update bit count
1102   5                                              }else{
1103   5                                                      if(captemp < HMT_SYNC){ // if sync pulse (opt, && sync preamble),
1104   6                                                              dmask = 0x01;                                   // reset data input registers (discard old data)
1105   6                                                              hm_data = 0;
1106   6                                                              bit_count = 0;
1107   6                                                              hm_status |= HM_START;                  // set start of frame
1108   6                      /*                                      if((!((hm_data >> (bit_count-7)) & 0x7F)) && (bit_count > 6)){
1109   6                                                                      if((!((hm_data >> (bit_count-7)) & 0x7F)) && (bit_count > 6)){
1110   6                                                                      hm_status |= HM_START;          // set start if proper sync
1111   6                                                              }else{
1112   6                                                                      hm_status |= HM_ERROR;          // else set error
1113   6                                                              }*/
1114   6                                                      }else{
1115   6                                                              hm_status |= HM_ERROR;                  // else set error
1116   6                                                      }
1117   5                                              }
1118   4                                      }
1119   3                                      if(bit_count == 20){                                            // if 20 bits, capture data & status
1120   4                                              temp = hm_hptr;                                                 // save ptr in case we overflow
1121   4                                              hm_buf[hm_hptr] = hm_data;
1122   4                                              hm_status_buf[hm_hptr++] = hm_status;
1123   4                                              if(hm_hptr > (HM_BUFMAX-1)) hm_hptr = 0; // roll-over head pointer
1124   4                                              if(hm_hptr == hm_tptr) hm_hptr = temp;  // buffer overflow, don't advance head
1125   4                                              dmask = 0x01;                                                   // reset data regs
1126   4                                              hm_data = 0;
1127   4                                              bit_count = 1;                                                  // only look for 19 bits on the 2nd try
1128   4                                              hm_status = 0;
1129   4                                      }
1130   3                              }
1131   2                      }
1132   1                      return;
1133   1      }
1134          
1135          //-----------------------------------------------------------------------------
1136          // Timer0_ISR
1137          //-----------------------------------------------------------------------------
1138          //
1139          // Called when timer 0 overflows (NORM mode):
1140          //      drives bbSPI by shifting 8 bits out MOSI at the timer rate/2 (the timer
1141          //                      sets the half clock period).
1142          //              If T0 enabled with spmask = 0, nothing happens except T0 is disabled when
1143          //                      the interrupt happens.  This is used to time the strobe pulse (external
1144          //                      code handles the strobe set/clear).
1145          //
1146          //-----------------------------------------------------------------------------
1147          
1148          void Timer0_ISR(void) interrupt 1
1149          {
1150   1              TR0 = 0;                                                                                // shouldn't get here, but turn off intrpt if we do
1151   1              return;
1152   1      }
1153          
1154          //-----------------------------------------------------------------------------
1155          // Timer1_ISR
1156          //-----------------------------------------------------------------------------
1157          //
1158          // Called when timer 1 overflows (NORM mode):
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 20  

1159          //      drives DDS
1160          //
1161          //-----------------------------------------------------------------------------
1162          /*
1163          void Timer1_ISR(void) interrupt 3 using 2
1164          {
1165                  // DDS vars
1166                  U8              pac;                            // temp regs
1167                  U16             pdac;
1168                  static U16      phaccum1;               // tone 1 phacc
1169                  static U16      phaccum2;               // tone 2 phacc
1170          
1171              TF1 = 0;                                                    // Clear Timer2 interrupt flag
1172                  
1173                  if(ipldds){
1174                          phaccum1 = 0;
1175                          phaccum2 = 0;
1176                          ipldds = 0;
1177                  }
1178                  // process phase accumulator 1
1179                  phaccum1 += delF1;                                                              // add delta for tone 1
1180                  pac = (U8)(phaccum1 >> 8);
1181                  pdac = (U16)SINE[pac];
1182          
1183                  // process phase accumulator 2
1184                  phaccum2 += delF2;                                                              // add delta for tone 2
1185                  pac = (U8)(phaccum2 >> 8);
1186                  pdac += (U16)SINE[pac];                                                 // add tone 2 DAC to holding reg
1187                  pdac >>= 1;                                                                             // div by 2 to get 8 bit combined tone DAC value
1188                  // store pdac to pwm
1189                  PCA0CPH1 = (U8)pdac;                                                    // storing here to sync update
1190          }*/
1191          
1192          //-----------------------------------------------------------------------------
1193          // Timer2_ISR
1194          //-----------------------------------------------------------------------------
1195          //
1196          // Called when timer 2 overflows (NORM mode):
1197          //              Runs at Fsamp rate with prescalers to produce app timers
1198          //      drives DDS & updates app timers @ 1ms rate
1199          //              rate = (sysclk) / (65536 - TH:L)
1200          //                       = 24500000 / (65536 - 0xfc00) = 24500000 / (65536 - 64512)
1201          //                       = 23.93 KHz
1202          //              / T2_MS1PS = 957 Hz = 1/1.05 ms (app timer update rate)
1203          //
1204          //-----------------------------------------------------------------------------
1205          
1206          void Timer2_ISR(void) interrupt 5 using 2
1207          {
1208   1              // DDS vars
1209   1              U8              pac;                            // temp regs
1210   1              U16             pdac;
1211   1              static U16      phaccum1;               // tone 1 phacc
1212   1              static U16      phaccum2;               // tone 2 phacc
1213   1      
1214   1          TF2H = 0;                                                   // Clear Timer2 interrupt flag
1215   1      
1216   1              if(ipldds){
1217   2                      phaccum1 = 0;
1218   2                      phaccum2 = 0;
1219   2                      ipldds = 0;
1220   2              }
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 21  

1221   1              // process phase accumulator 1
1222   1              phaccum1 += delF1;                                                              // add delta for tone 1
1223   1              pac = (U8)(phaccum1 >> 8);
1224   1              pdac = (U16)SINE[pac];
1225   1      
1226   1              // process phase accumulator 2
1227   1              phaccum2 += delF2;                                                              // add delta for tone 2
1228   1              pac = (U8)(phaccum2 >> 8);
1229   1              pdac += (U16)SINE[pac];                                                 // add tone 2 DAC to holding reg
1230   1              pdac >>= 1;                                                                             // div by 2 to get 8 bit combined tone DAC value
1231   1              // store pdac to pwm
1232   1              PCA0CPH1 = (U8)pdac;                                                    // storing here to sync update
1233   1      
1234   1              // U8 timers
1235   1              if(--t2pscl == 0){
1236   2                      t2pscl = T2_MS1PS;                                                      // reset ms prescaler
1237   2                      if(waittimer != 0){                             // g.p. delay timer
1238   3                              waittimer--;
1239   3                      }
1240   2                      if(dbounceHM_tmr != 0){                         // pbsw debounce timer
1241   3                              dbounceHM_tmr--;
1242   3                      }
1243   2                      // U16 timers
1244   2                      if(hmkey_timer){
1245   3                              if(--hmkey_timer){
1246   4                                      hmkey_timer_flag = 0;
1247   4                              }
1248   3                      }
1249   2                      if(ud_timer){                                                           // key timer
1250   3                              if(--ud_timer == 0){
1251   4                                      ud_timer_flag = 0;
1252   4                              }
1253   3                      }
1254   2                      if(press_timer){                                                        // key press timer and flag
1255   3                              press_timer--;
1256   3                              if(!press_timer){
1257   4                                      press_flag = 1;
1258   4                              }
1259   3                      }
1260   2                      if(wr_timer != 0){                                                      // wired-remote timer and flag
1261   3                              wr_timer -= 1;
1262   3                              if(wr_timer == 0){
1263   4                                      wr_flag = 1;
1264   4                              }
1265   3                      }
1266   2                      if(wra_timer != 0){                                                     // wired-remote timer and flag
1267   3                              wra_timer -= 1;
1268   3                              if(wra_timer == 0){
1269   4                                      wra_flag = 1;
1270   4                              }
1271   3                      }
1272   2              }
1273   1      }
1274          
1275          //#undef IS_MAINC
1276          //**************
1277          // End Of File
1278          //**************


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2500    ----
C51 COMPILER V9.55   MAIN                                                                  06/30/2022 20:47:14 PAGE 22  

   CONSTANT SIZE    =    243    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     52      27
   IDATA SIZE       =     38       9
   BIT SIZE         =      6       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
