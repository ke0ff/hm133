C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(2,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /****************************************************************************************
   2           ****************** COPYRIGHT (c) 2020 by Joseph Haas (DBA FF Systems)  *****************
   3           *
   4           *  File name: main.c
   5           *
   6           *  Module:    Control
   7           *
   8           *  Summary:   This is the main code file for the HM133 DTMF application
   9           *      License and other legal stuff:
  10           *                         This software, comprised of all files contained in the original distribution archive,
  11           *                              are protected by US Copyright laws.  The files may be used and modified by the person
  12           *                              receiving them under the following terms and conditions:
  13           *                              1) The software, or any protion thereof may not be distributed to any 3rd party by
  14           *                                      the recipient or any agent or assign of the recipient.
  15           *                              2) The recipient assumes all risks for the use (or mis-use) of this software.
  16           *
  17           *
  18           *  Project scope revision history:
  19           *        *** REV w04r ***
  20           *        06-26-22 jmh:  Deprecated bluetooth remote.  Removed serial input and bluetooth module.  Replaced wit
             -h wired_rmt module.
  21           *                                       Wired remote sends commands in the blind to the target host.
  22           *
  23           *    08-22-20 jmh:  IC901 remote control head mods: Supports a wired-remote master/slave to provide 6 rem
             -ote GPIO signals
  24           *        *** REV 04r ***
  25           *    08-22-20 jmh:  IC901 remote control head mods: Supports a wired-remote master/slave to provide 6 rem
             -ote GPIO signals
  26           *                                       aimed at simulating keypresses on the IC-901 (or, possibly, other) radio control head.
  27           *                                       The uCHIP RN4871 is used as the master (it is smaller, but has limited I/O) and the RN4780 is the 
             -slave.
  28           *                                       The RN4780 has only 5 GPIOs, but one of the PWM outputs is used as a 6th output by operating it at
             - 0.5%
  29           *                                       or 99.5% and filtering out the carrier with an RC filter.  The following summary lists the SW/HW
  30           *                                       modifications made to support this feature:
  31           *
  32           *                                              - re-arranged timers 1 & 2 so that timer1 can drive UART baud clock to 115.556k Kb (0.3% above the
  33           *                                                      nominal 115.2 Kb)
  34           *                                              - added serial.c and modified to interface with BT module comms
  35           *                                              - revamped RAM useage (using "idata" and "data" segment IDs) to get the linker happy again.  The
  36           *                                                      RAM is heavily utilized leaving very little room for error or bloat.
  37           *                                              - added wired-remote.c to hold wired remote process machine and Fns.
  38           *                                              - Tasked P0.6 as the "Mute-on-RX" enable.  Grounding P0.6 enables the SMUTE toggle on PTT edge
  39           *                                                      feature.  Operator configures SMUTE as desired for RX, and the system will enable/disable
  40           *                                                      on PTT edges.  Just in time for Christmas, no less.
  41           *                                              - folded in button tasks in the main() process loop.  Buttons now provide the following functions:
  42           *
  43           *                                                              HM-151 KEYPAD:
  44           *
  45           *                                                              LOCK (L)        TUNER (T)         XFC (X)
  46           *                                                              Scan (up)       CALL              M/S
  47           *
  48           *                                                              upARROW (/)             V/M (V)   MW (M)
  49           *                                                                 UP                     V/M      H/L
  50           *
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 2   

  51           *                                                              dnARROW (\)             F1 (F)    F2 (f)
  52           *                                                                 DN                     SET      SUB
  53           *
  54           *                                                              (1)             (2)             (3)               MODE (A)
  55           *                                                              <Digits 0-9 = DTMF if >     MODE
  56           *
  57           *                                                              (4)             (5)             (6)               FIL  (B)
  58           *                                                              <PTT active, or pulse >     TSQ
  59           *
  60           *                                                              (7)             (8)             (9)               GENE (C)
  61           *                                                              <accum input otherwise>     BAND
  62           *                                                                                                                                                      -% The toggle CHECK feature sets the check switch,
  63           *                                                              . (*)   (0)             CE (#)    ENT  (D)                         then enters a special hold state.  Any bluethooth
  64           *                                                              Togg                    Togg        SMUTE                          key will then open the CHECK button, exit the hold
  65           *                                                              LED brt                 CHECK -%                                           state, and return to normal key operation.
  66           *
  67           *                                                      Characters in () identify the keymap code that is used in the system.  Togg LED Brightness
  68           *                                                      clears the pulse accumulator.
  69           *                      DEPRECATED ***                  - Status LED now will blink Morse for "A" until the wired-remote link is connected a
             -nd secured.
  70           *                                                                      This needs to be augmented with a retry trap to abort BT connect after 5 or so tries.
  71          ////
  72           *        *** REV 04 ***
  73           *    03-14-20 jmh:  Fixed bug with U16 ISR timers.
  74           *        *** REV 03 ***
  75           *    03-10-20 jmh:  Modified pulse() to accept U16 pulse timer (modified pulse timer also).  Rig array
  76           *                                              still stores U8, so it must be cast when the rig type is read on power-up.
  77           *                                       Modified ICOM mode to use MR(TUNER) as scan up, and F-1(V/M) as scan down.  These
  78           *                                              keys instantiate an 800ms pulse on up or dn to start the scan mode.
  79           *                                       Modified ICOM pulse period to 45 ms (was 40).
  80           *                                       Added named rig types for Kenwood and generic 100 and 125.
  81           *                                       Fixed several code snippets for "VERS == 1" build case.
  82           *        *** REV 02 ***
  83           *    08-28-19 jmh:  Debug of HM151 mode.  Tested on IC-7000.  Found that the first key is ignored if no
  84           *                                              other keys are detected after.  This means that the F-2 key needn't be set to a
  85           *                                              null command (can't do this anyway).  Also verified that HM-151 keys are active
  86           *                                              during TX.
  87           *                                       Modified code to trap leading and falling edge of 'G' key.  If entering pass-thru
  88           *                                              mode, delay DMUTE switch until release of 'G', else switch DMUTE immediately.
  89           *                                       Revamped init code to make sure DMUTE is not set to pass-thru until just before the
  90           *                                              start of the MPL.
  91           *                                       Added timer clear statements to init code to cover warm start case.
  92           *        08-19-19 jmh:  Added pulse delay variable to radio_fbtn[][] array.  Kenwood needs at least 80ms,
  93           *                                              ICOM can take 40ms.  Other delays up to 125 are also included.
  94           *                                       HW MOD: changed comparator voltage ref to a voltage divider driven from M8V to
  95           *                                              follow what the radios do.
  96           *                                       HW MOD: changed how 5V is wired to reset circuit.  Debug adapter now works at
  97           *                                              least as well as with the 3.3V bypass Vreg.
  98           *        08-18-19 jmh:  VERS 2 testing continues...
  99           *                                       Tested HM151 mode & corrected LED functions.  *** Need to test with IC-7000.
 100           *                                       Abandoned SPR as a strap, made Ro3 3rd strap.
 101           *                                       *** need to test option straps.
 102           *        08-17-19 jmh:  VERS 2 initial bring-up complete.  Issues:
 103           *                                              1) The dual FET footprint was wrong.  Had to re-map 4094 bitmap to correct.
 104           *                                                      LED and DMUTE had to be re-wired, so no SW change for those signals.
 105           *                                                      PCB rev 003 update complete.  Added Ro3 "gimmick" resistor to make P0.6
 106           *                                                      the 3rd strap option.  *** Need to see if this works. ***
 107           *                                              2) Voltage reg either broke or some configuration issue.
 108           *                                                      Flaky debug and operation modes - will look again at this on 2nd build.
 109           *                                                      1st article has a 3V regulator piggy-backed on the 5V Vreg with a jumper to
 110           *                                                      U2 Vdd net (Vregi pin is lifted).  U5 Vhi is about 2.9V...not sure this
 111           *                                                      can be counted on to work all the time.
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 3   

 112           *                                       Made some code tweaks to get DTMFs to work correctly.  Not sure why they broke going
 113           *                                              to rev 002 HW.  Also, cleaned up some commented-out code (still some left).
 114           *                                       Added "mic present" mirror.  If strap selects HM151, DN0 = MIC_DET_N any time MIC_DET_N
 115           *                                              changes state.  In addition to mirror, this code kills PTT and tone related registers
 116           *                                              and clears DMUTE if the mic is removed.
 117           *                                              Added restart capability to re-initialize system when mic is removed.  Code will
 118           *                                              continually restart until mic is re-connected.
 119           *                                       Resticted all keys but "M" in HM151 mode.  DTMFs will generate if PTT pressed & DMUTE
 120           *                                              is active.
 121           *        08-15-19 jmh:  HM133 DTMF now works (mostly).  PTT can NOT be pressed if HM133 DTMF-S is active.
 122           *                                              May not need HM133/HM151 strap-opt.
 123           *                                       Strap support for revA *mostly* working.
 124           *                                       1st key logic now traps "1st" 1st key and ignores following until button released.
 125           *        08-12-19 jmh:  Added support for straps.  radio_fbtn[][] array holds transistor pulse patterns that
 126           *                                              correspond to key/rig combinations.
 127           *                                       Added support for extended buttons (MC-44/MH-36) in the button operations switch{} and
 128           *                                              in the support Fns.
 129           *                                       Changed pulse_up/pulse_dn to a single funtion which now supports all of the transistor
 130           *                                              outputs of the CD4094 SR port expander.
 131           *                                       VERS 1 now support using DMUTE for a single expansion button (since it won't do the
 132           *                                              HM151 FT option correctly).
 133           *                                       Added support for HM151 FT mode.  Fn LED = off if in FT mode, else, on for DTMF enabled mode.
 134           *    08-09-19 jmh:  Added #if directives to support PCB version 2.  Re-mapped PTT, UP, and DN bit control
             -s
 135           *                                              to use a central Fn to set/clear bits.  Paves the way for port extender to be used
 136           *                                              in version 2 PCB.  bbSPI code is in place for port expander.  Waveforms verified on
 137           *                                              o'scope, but not tested.  Port update uses TIMER0 ISR to clock 8 bits and strobe
 138           *                                              CD4094 port expander I.C..  XFR plus STB takes about 45us.
 139           *        08-07-19 jmh:  Added feature to interrupt U/D macros on any keypress
 140           *                                       Added feature to change Fn LED brightness.  If no PTT, "*" = dim, "#" = brt.
 141           *
 142           *    08-04-19 jmh:  basic functionality working with HM-151.  HM-133 DTMFs need work.
 143           *                                       added a DTMF activity timer for HM-151 so that the MIC is unmuted
 144           *                                              after an interval of no DTMF key being pressed.
 145           *                                       The "Fn LED" now depicts mic mute status during tone cycles.  Off =
 146           *                                              muted (or macro digit pressed), ON = unmuted.  Blink = up/dn pulse.
 147           *
 148           *        *** REV 01 ***
 149           *        08-03-19 jmh:  project baselined at rev 01
 150           *    07-20-19 jmh:  Project origin, copied from Orion PLL
 151           *
 152           ***************************************************************************************/
 153          
 154          /****************************************************************************************
 155           *  File scope revision history:
 156           *  06-26-22 jmh:   modified to support wired-remote control head interface 
 157           *  04-09-16 jmh:       creation date
 158           *
 159           ***************************************************************************************/
 160          
 161          //--------------------------------------------------------------------------------------
 162          // main.c
 163          //
 164          //      The following resources of the F531 are used:
 165          //      24.500 MHz internal osc
 166          //
 167          //      UART: RDU command output
 168          //
 169          //      Timer0: bbSPI clock driver
 170          //      Timer1: UART baud clock
 171          //      Timer2: DDS sample driver (23.925 KHz) & Application timer (1ms/tic)
 172          //
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 4   

 173          //      ADC: n/u
 174          //
 175          //      PCA: 
 176          //                       CEX0 = ICOM mic data decode ISR
 177          //                       CEX1 = tone DDS PWM
 178          //                       CEX2 = Aux LED PWM out (Fixed PWM ratio, no ISR)
 179          //
 180          //      SYSTEM NOTES:
 181          //
 182          //              This project adapts an HM-133 (or HM-151) microphone so that it can produce DTMF signals.
 183          //              The PCB features the F531 MCU, a 3.3V regulator, open-drain drivers for up/dn and PTT, and
 184          //              switching circuits for the microphone/DTMF signals.  The small form-factor board is intended
 185          //              to be an in-line module between the microphone and the transciever.  Additional features
 186          //              such as up/down toggle commands are also possible allowing a specific number of pulses (up or
 187          //              dn) to be issued to the connected radio.  DTMF memories are also possible using spare FLASH
 188          //              to hold the sequences.
 189          //
 190          //              DTMF signals are generated using DDS code running the PCA CEX1 output in 8-bit PWM mode.  If
 191          //              a keypress is recieved while the PTT is active (from either the PTT input discrete or the PTT
 192          //              keycode), the system will turn on the appropriate DTMF pair until the key is released, or PTT
 193          //              goes inactive.  Since PCA can't do an 8-bit regular interrupt, Timer2 is used to drive the sample
 194          //              clock.  Thus, the DDS ISR code lives inside Timer2, and updates the PWM register.  Timer2 needs to
 195          //              run at the same rate as the PCA to preserve update alignment.
 196          //
 197          //              The DDS is currently being driven at FSAMP = 23,925 Hz to ease the filtering requirements.  This
 198          //              increases the Fstep to 0.365Hz, but this is still well below the worst-case 10.4Hz ETSI requirement
 199          //              for DTMF.
 200          //
 201          //              PCA CEX2 is used to drive an "AUX" LED on the HM-133 (typically blue, and is user installed near
 202          //              the u/d buttons on the HM-133/151).  It is a fixed PWM output to provide a fine adjustment to the
 203          //              LED brightness.  LED on/off/brightness can be used to convey status (power on, DTMF output, PGM
 204          //              mode enabled, etc...).
 205          //
 206          //              The software also interprets HM-133 key codes to drive the PTT and U/D open-drain discretes.
 207          //              U/D also features a tiered pulse ramp whereby the initial keypress sends one pulse, then after
 208          //              1 second of holding, the system begins pulsing at 5 Hz.  After 3 seconds of keypress, the
 209          //              system begins pulsing at 10 Hz.  Pulsing stops imeediately upon release of the key.
 210          //
 211          //              This is the "non" wired-remote SW version which uses a direct connection from TXD to the target RDU
 212          //              to transfer keypress messages at 115200 baud.
 213          //              HM-133 TX commands are 5-bytes long: <'~'><cmd><d/u/h><chk><\r>
 214          //                              <'~'> is fixed preamble
 215          //                              <cmd> is a single-byte alpha-numeric key ID command
 216          //                              <p/r/h> is a single character for key (p)ress, (r)elease, or (h)old
 217          //                              <chk> = (<cmd> EOR <p/r/h>) OR 0x80
 218          //                              <\r> is <CR>, ASCII 0x0d
 219          //
 220          //              First, send "p" param.  As long as key is held, send "h" param at 500ms rate.  Send "r" param as soon
 221          //              as key is released.
 222          //
 223          //--------------------------------------------------------------------------------------
 224          
 225          //-----------------------------------------------------------------------------
 226          // Includes
 227          //-----------------------------------------------------------------------------
 228          // compile defines
 229          #include "init.h"
 230          #include "typedef.h"
 231          #include "c8051F520.h"
 232          #include "serial.h"
 233          #include "wired_rmt.h"
 234          
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 5   

 235          //-----------------------------------------------------------------------------
 236          // Definitions
 237          //-----------------------------------------------------------------------------
 238          
 239          // DEPRECATED... THIS SW DOESN'T SUPPORT VERS == 2
 240          //#define       VERS    1                               // PCB vers 2 uses 4094 port expander, else VERS = 1
 241                                                                          // !! IC-901 expander code (this project) is currently only valid for VERS = 1 !!
 242          
 243          //#define       IS_SIM                          // enable this define if using simulator
 244          
 245          //  see init.h for #defines
 246          
 247          
 248          //-----------------------------------------------------------------------------
 249          // External Variables
 250          //-----------------------------------------------------------------------------
 251          
 252          extern code const U8    SINE[];
 253          idata volatile  U16             hmd_timer;                                              // HM151 data idle timeout timer
 254          
 255          //-----------------------------------------------------------------------------
 256          // Main Variables
 257          //-----------------------------------------------------------------------------
 258          
 259          // port assignments
 260          
 261          // PCB version 1 bit defines
 262          sbit MDATA              = P1^7;                         // (a) mic data in
 263          sbit MMUTE_N    = P1^6;                         // (o) mic mute out (act low)
 264          sbit PTTb               = P1^5;                         // (o) PTT out to rig (act hi)
 265          sbit DNb            = P1^4;                             // (o) mic DN button out to rig (act hi)
 266          sbit UPb            = P1^3;                             // (o) mic UP button out to rig (act hi)
 267          sbit CMP_IN             = P1^2;                         // (a) comparator (+) input (VREF with hysteresis)
 268          sbit PTTM_N     = P1^1;                         // (i) mic PTT in (act low)
 269          sbit DMUTE              = P1^0;                         // (o) rig data mute out (act hi)
 270          
 271          
 272          sbit PTT_CALL   = P0^6;                         // (i) PTT/CALL enable (if GND)
 273          sbit MDATA_IN   = P0^2;                         // (i) limited serial data input (connected to comparator out)
 274          
 275          
 276          //-----------------------------------------------------------------------------
 277          // Local variables
 278          //-----------------------------------------------------------------------------
 279          #define HM_START        0x01
 280          #define HM_ERROR        0x02
 281          #define HM_BUFMAX       3                                                               // HM-133/151 buffers and working regs
 282                          volatile        U8              hm_hptr;                                                // save ptr in case we overflow
 283                          volatile        U8              hm_tptr;                                                // HM-133/151 key buffer tail ptr
 284          idata   volatile        U32             hm_buf[HM_BUFMAX];
 285                          volatile        U8              hm_status_buf[HM_BUFMAX];
 286                          volatile        U8              hm_ctptr;                                               // capture buf tail ptr
 287                          volatile        U8              hm_chptr;                                               // capture buf head ptr
 288          idata   volatile        U32             sys_error_flags;                                // system error flags
 289          idata   volatile        char    curr_key;
 290          
 291                          volatile        U8              ipldds;                                                 // dds ISR init flag
 292                          volatile        U16             delF1;                                                  // phase (tone) register for tone 1
 293                          volatile        U16             delF2;                                                  // phase (tone) register for tone 2
 294          
 295                          volatile        U8              t2pscl;                                                 // t2 prescaler
 296                          volatile        U16             hmkey_timer;                                    // key timer
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 6   

 297                                                  U8              hmkey_timer_flag;
 298                          volatile        U8              waittimer;                              // wait() function timer
 299                          volatile        U8              dbounceHM_tmr;
 300                          volatile        U8              iplTMR;                                     // timer IPL init flag
 301                          volatile        U16             press_timer;                                    // key press timer and flag
 302                          volatile        U8              press_flag;                                             // key-press timeout flag
 303                                                  U16             pulse_delay;                                    // pulse delay value
 304          #define UD_PERIOD       10                                                              // up/dn pulse period
 305                          volatile        U16             ud_timer;
 306                                                  U8              ud_timer_flag;
 307                          volatile        bit             wr_flag;
 308                          volatile        U16             wr_timer;
 309                          volatile        bit             wra_flag;
 310                          volatile        U16             wra_timer;
 311                          volatile        U8              xport;                                                  // expansion port data register
 312          
 313          // bbSPI registers
 314                          volatile        U8              spdr;
 315                          volatile        U8              spmask;
 316          
 317          // HM133/151 ISR data decode vars
 318          idata   volatile        U32     dmask;                                                          // data mask
 319          idata   volatile        U32     hm_data;                                                        // data register
 320                          volatile        U8      hm_status;                                                      // status register
 321                          volatile        U16     last_edge;                                                      // last edge capture (sign extended to 32 bits)
 322                          volatile        U8      bit_count;                                                      // count of # bits rcvd
 323          
 324          // HM-133/151 code LUT arrays:
 325          #define MAX_KEY 25                                                                      // # keys on HM-151
 326          #define MAX_KEY_133     23                                                              // # keys on HM-133
 327          
 328          //      HM-133: there are actually 25 keys, but two of them act as modifiers
 329          //        (func and dtmf) and do not send a key code.  The keys have different
 330          //        labeling, but each key is in roughly the same position with the same
 331          //        code.  However, many keys are labeled differently from the HM-151.
 332          //        HM-133 applications should use the following key map:
 333          //              Key code        Function (key)                                          HM-151 function (key)
 334          //                M                     F2                                                                      MR
 335          //                V                     F1                                                                      V/M
 336          //                X                     Band change                                                     XFC
 337          //                T                     MR (and MW with persistent press)       TUNER/CALL
 338          //                L                     VFO                                                                     SPCH/LOCK
 339          //                F                     n/a                                                                     F1
 340          //                G                     n/a                                                                     F2
 341          //
 342          // HM-133 function key return set.  '%' and '!' are placekeepers to keep
 343          //      alignment with the key_addr[] array.  These codes should never be sent
 344          //      by an HM-133.  HM-151 doesn't have a FUNC mode, so it will never send
 345          //      any of these codes.
 346          // !! These codes don't mean anything to the adapter, so they are included as comments
 347          //      for completeness. !!
 348          /*code char fnkey_code[] = { 'p',   'o',   'n',   'k',   'm',   'l',   'j',  '%',
 349                                                    '!',   'a',   'b',   'c',   'q',   'd',   'e',   'f',
 350                                                    'r',   'g',   'h',   'i',   's',   '+',   '`',   '$',
 351                                                    't',   '\0' };*/
 352          // Normal mode keycodes for HM-151 and HM-133 (see above for HM-133 notes)
 353          code char key_code[] = { 'L',   'T',   'X',   '/',   'V',   'M',   '\\',  'F',
 354                                                  'G',   '1',   '2',   '3',   'A',   '4',   '5',   '6',
 355                                                  'B',   '7',   '8',   '9',   'C',   '*',   '0',   '#',
 356                                                  'D',   '\0' };
 357          
 358          #define DTMF_OFFS       (9)             // offset to subtract from key_code index to become dtmf index
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 7   

 359                                                                  // this offset is dependent on the placement of keycodes in the
 360                                                                  // "_code" tables above.  SO...don't re-arrange the key_code[] table!
 361          
 362          // DTMF tone lookup tables for row and column
 363          code U16 dtmf_row[] = { ROW1_TONE, ROW1_TONE, ROW1_TONE, ROW1_TONE,
 364                                                      ROW2_TONE, ROW2_TONE, ROW2_TONE, ROW2_TONE,
 365                                                      ROW3_TONE, ROW3_TONE, ROW3_TONE, ROW3_TONE,
 366                                                      ROW4_TONE, ROW4_TONE, ROW4_TONE, ROW4_TONE,
 367                                                    };
 368          code U16 dtmf_col[] = { COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 369                                                      COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 370                                                      COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 371                                                      COL1_TONE, COL2_TONE, COL3_TONE, COL4_TONE,
 372                                                    };
 373          // serial key codes less the func/dtmf/1stkey modifier nybble.
 374          code U16 key_addr[] =  {0x0b02,0x1302,0x2302,0x2202,0x0a02,0x1202,0x2002,0x1002,
 375                                             0x0802,0x0b82,0x1382,0x2382,0x4382,0x0982,0x1182,0x2182,
 376                                             0x4182,0x0a82,0x1282,0x2282,0x4282,0x0882,0x1082,0x2082,
 377                                             0x4082,0x0000};
 378          
 379          // The first index selects the radio type, the second index selects the button.
 380          //      The array return is written to the port expansion SR to select the desired Fn.
 381          code U8 radio_fbtn[] = { UP, UP1,      UP2,         DN, DN1,          DN2,      MS45};          // 0    generic (ICOM
             -)
 382          //              HM133 button -->        UP  F1        VFO/LOCK     DN  MR/CALL       BAND/OPT   Pulse Delay
 383          //                                                      |   |         |            |   |             |                  |
 384          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,      MS45},               // 0    generic (ICOM)
 385          //                                                { UP, MH36_ACC, MH36_P1,     DN, MH36_DMR,     MH36_P2, MS100},               // 1    Yaesu MH36
 386          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,      MS80},               // 2    Kenwood
 387          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS100},               // 3    generic (ICOM/KW) <- place
             -keeper for new rig type
 388          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS125},               // 4    generic (ICOM/KW) <- place
             -keeper for new rig type
 389          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS125},               // 5    generic (ICOM/KW) <- place
             -keeper for new rig type
 390          //                                                { UP, UP1,      UP2,         DN, DN1,          DN2,     MS125},               // 6    generic (ICOM/KW) <- place
             -keeper for new rig type
 391          //                                                { 0,    0,        0,          0,   0,            0,         0}                // 7    HM-151 (IC-7000) -- no up/d
             -n or other outputs supported
 392          //                                            };                                                                                                                                        //              for this mic
 393          
 394          code U8 swopt_pattern_lut[] = {
 395                  // "a" = 00000001, mask = 00000010
 396                  0x01,
 397                  // "b" = 00001000, mask = 00001000
 398                  0x08,
 399                  // "c" = 00001010, mask = 00001000
 400                  0x0a,
 401                  // "d" = 00000100, mask = 00000100
 402                  0x04,
 403                  // "e" = 00000000, mask = 00000001
 404                  0x00,
 405                  // "f" = 00000010, mask = 00001000
 406                  0x02,
 407                  // "g" = 00000110, mask = 00000100
 408                  0x06,
 409                  // "h" = 00000000, mask = 00001000
 410                  0x00 };
 411          
 412          code U8 swopt_mask_lut[] = {
 413                  // "a" = 00000001, mask = 00000010
 414                  0x02,
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 8   

 415                  // "b" = 00000001, mask = 00001000
 416                  0x08,
 417                  // "c" = 00000101, mask = 00001000
 418                  0x08,
 419                  // "d" = 00000100, mask = 00000100
 420                  0x04,
 421                  // "e" = 00000000, mask = 00000001
 422                  0x01,
 423                  // "f" = 00000010, mask = 00001000
 424                  0x08,
 425                  // "g" = 00000110, mask = 00000100
 426                  0x04,
 427                  // "h" = 00000000, mask = 00001000
 428                  0x08 };
 429          
 430          //-----------------------------------------------------------------------------
 431          // Local Prototypes
 432          //-----------------------------------------------------------------------------
 433          
 434          void process_hm(U8 flag);
 435          void flash_swvers(U8 pattern, U8 mask);
 436          void pulse(U8 discr, U8 pcount, U16 pdly);
 437          void outbit(U8 bitmap, U8 on);
 438          void send8(U8 sdata);
 439          U8 get_opt(void);
 440          U8 got_hmd(void);
 441          S32 get_hmd(void);
 442          char* get_hmcode(U32 keym);
 443          
 444          //******************************************************************************
 445          // main()
 446          //  The main function inits I/O and process I/O.
 447          //
 448          //******************************************************************************
 449          void main(void) //using 0
 450          {
 451   1      idata   volatile U8             i;                              // temp uchar
 452   1      idata   volatile U8             j;
 453   1      static  idata    U8             q;                              // DTMF-S temp
 454   1      static  idata    U8             t;                              // DTMF-S temp
 455   1      static                   bit    mdet_edge;              // mic det edge reg
 456   1      static  data     U8             new_events;
 457   1      //static        data     U8             dmute_mem;              // reg to hold initial dmute status when "G" key detected
 458   1      idata volatile char             d;                              // temp char
 459   1      static            char*         dp;                             // pointer to key code array
 460   1      #define MAX_ACCUM       99
 461   1      idata   volatile U8             accum;                  // u/d pulse-count accumulator
 462   1      static  data    U32             si;                             // temp 32
 463   1      static  idata    U8             hm_count;               // hm key repeat counter
 464   1      static  idata    U8             keyh_mem;               // current key (used to determine 1st keypress)
 465   1      static                  bit             keyh_edg;               // 1st key edge
 466   1      static                  bit             ptt_edge;               // edge discrete
 467   1      static                  bit             aflag;                  // accum repeat inhib flag
 468   1      static  data     U8             softptt;                // soft ptt detected
 469   1      //data  volatile U8             swopt;                  // SW ipl strap options
 470   1                      volatile U8             run;                    // warm restart trigger
 471   1      
 472   1              // start of main
 473   1              while(1){                                                                       // outer loop is for soft-restart capability
 474   2                      PCA0MD = 0x00;                                                  // disable watchdog
 475   2                      EA = 0;
 476   2                      // init MCU system
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 9   

 477   2                      Init_Device();                                                  // init MCU
 478   2                      t2pscl = T2_MS1PS;                                              // init prescaler
 479   2                      EA = 1;
 480   2                      xport = 0;                                                              // init expansion port
 481   2                      // VERS 1 port init
 482   2                      PTTb = 0;                                                               // (o) PTT out to rig (act hi)
 483   2                      DNb = 1;                                                                // (o) mic DN button out to rig (act hi)
 484   2                      UPb = 0;                                                                // (o) mic UP button out to rig (act hi)
 485   2                      DMUTE = 0;                                                              // (o) rig data mute out (act hi)
 486   2                      MDATA_IN = 1;                                                   // (i) mic data in
 487   2                      MDATA = 1;
 488   2                      CMP_IN = 1;
 489   2                      PTT_CALL = 1;
 490   2                      init_serial();
 491   2                      pulse_delay = (U16)radio_fbtn[IDX_PLSDLY]; // fetch pulse delay
 492   2                      MDATA = 1;
 493   2                      MMUTE_N = UNMUTE_BIT;                                   // (o) mic mute out (act low)
 494   2                      PTTM_N = 1;                                                             // (i) mic PTT in (act low)
 495   2                      DMUTE = 1;                                                              // (o) rig data mute out (act hi)
 496   2                      // init module vars
 497   2                      iplTMR = TMRIPL;                        // timer IPL init flag
 498   2                      PCA0CPM1 &= 0xfe;                                               // disable CCF1
 499   2                      dmask = 0x01;                                                   // reset data regs
 500   2                      hm_data = 0;
 501   2                      bit_count = 0;
 502   2                      hm_status = 0;
 503   2                      last_edge = 0;
 504   2                      keyh_edg = 0;
 505   2                      delF1 = 0;                                                              // cler the DDS tone regs
 506   2                      delF2 = 0;
 507   2                      hmkey_timer = 0;
 508   2                      waittimer = 0;
 509   2                      dbounceHM_tmr = 0;
 510   2                      press_timer = 0;
 511   2                      press_flag = 0;
 512   2                      ud_timer = 0;
 513   2                      accum = 0;
 514   2                      ipldds = 1;                                                             // ipl the DDS
 515   2      //              init_serial();                                                  // init UART
 516   2                      // process IPL init
 517   2                      keyh_mem = KEY_NULL;
 518   2                      hm_count = 0;
 519   2                      aflag = 0;
 520   2                      softptt = 0;                                                    // init soft PTT
 521   2                      mdet_edge = 1;
 522   2      
 523   2                      #ifndef IS_SIM                                                  // skip DDS wait for sim
 524   2                      while(ipldds);                                                  // wait for DDS to init
 525   2                      #endif
 526   2                      
 527   2                      #ifdef  IS_SIM                                                  // allows range-checking of big constants in simulator
                              delF1 = HMT_SYNC;                                               // place constant expressions here for a quick check
                              delF1 = COL4_TONE;
                              #endif
 531   2      
 532   2                      // serial debug version msg
 533   2      //              putss("IC901RCH VR4\n\r");
 534   2                      i = RSTSRC;
 535   2                      putch('~');
 536   2                      putch(hiasc(i));
 537   2                      putch(lowasc(i));
 538   2                      putch('\r');
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 10  

 539   2      
 540   2                      // flash version (R4) and radio select code:
 541   2                      //       "R" = 00000010 = 0x02          mask = 00000100 = 0x04
 542   2                      flash_swvers(0x02, 0x04);
 543   2                      //       "4" = 00000001 = 0x01          mask = 00010000 = 0x10
 544   2                      flash_swvers(0x01, 0x10);
 545   2                      DMUTE = 1;                                                              // inhibit pass-thru
 546   2                      PCA0CPM2 |= 0x40;                                               // fn led on (ECOM);
 547   2                      ptt_edge = ~PTTM_N;
 548   2                      process_WR(STATE_INIT);                                 // init wired-remote process
 549   2                      run = 1;                                                                // enable run
 550   2                      wait(2);
 551   2                      // main loop
 552   2                      while(run){                                                                                                     // inner-loop runs the main application
 553   3                              process_WR(K_NULL);                                                                             // process hold timer                                                   
 554   3                              new_events = 0;
 555   3                              d = PTTM_N;
 556   3                              if(d != ptt_edge){                                                                              // process manual PTT input
 557   4                                      if(!PTT_CALL){
 558   5                                              process_WR(SMUTE);                                                              // toggle smute button on PTT edge if P0.6 == GND
 559   5                                      }
 560   4                                      ptt_edge = d;
 561   4                                      if(d){                                                                                          // PTT input is ground true
 562   5                                              MMUTE_N = MUTE_BIT;                                                             // PTT released
 563   5                                              outbit(PTT, 0);
 564   5                                              delF1 = 0;
 565   5                                              delF2 = 0;
 566   5                                              PCA0CPM2 |= 0x40;                                                               // fn led on (ECOM);
 567   5                                              // turn off PWMO ISR
 568   5                                              PCA0CPM1 &= 0xfe;
 569   5                                      }else{
 570   5                                              outbit(PTT, 1);                                                                 // PTT pressed
 571   5                                              MMUTE_N = UNMUTE_BIT;
 572   5                                      }
 573   4                              }
 574   3                              d = '\0';
 575   3      
 576   3                              if(got_hmd()){                                                                                  // trap keys
 577   4                                      new_events = KEYHM_CHNG;
 578   4                                      dbounceHM_tmr = 150;
 579   4                              }
 580   3                              if(dbounceHM_tmr == 0){
 581   4                                      if(keyh_mem != KEY_NULL){                                                       // trap debounce timeouts
 582   5                                              new_events |= KEYHM_CHNG;
 583   5                                      }
 584   4                              }
 585   3                              if(delF1){
 586   4                                      press_timer = MS1650;                                                           // reset DTMF timer anytime a tone is being generated
 587   4                              }
 588   3                              if(press_flag){                                                                                 // keypress timeout, enable mic
 589   4                                      press_flag = 0;
 590   4                                      PCA0CPM2 |= 0x40;                                                                       // fn led back on (ECOM);
 591   4                                      MMUTE_N = UNMUTE_BIT;                                                           // unmute mic
 592   4                              }
 593   3                              // this branch handles key-driven events
 594   3                              if(new_events & KEYHM_CHNG){                                                    // process trapped events
 595   4                                      if(!softptt){
 596   5                                              if(dbounceHM_tmr == 0){                                                 // process no-key from HM-133/151
 597   6                                                      keyh_edg = 0;
 598   6                                                      if(keyh_mem != KEY_NULL){
 599   7                                                              // release key
 600   7                                                              if(!delF1){
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 11  

 601   8                                                                      PCA0CPM2 |= 0x40;                                       // led back on if no tone (ECOM);
 602   8                                                              }
 603   7                                                              aflag = 0;                                                              // release accum inhibit
 604   7                                                              i = keyh_mem | 0x80;                                    // set release keypress
 605   7                                                              process_WR(K_REL);                                              // release key to remote host
 606   7                                                      }
 607   6                                                      keyh_mem = KEY_NULL;                                            // if no key, clear current key mem.
 608   6                                              }
 609   5                                      }
 610   4                                      si = get_hmd();                                                                         // get hm-133/151 data word
 611   4                                      dp = get_hmcode(si);                                                            // do key-code lookup, pointer is set to keycode array
 612   4                                      d = *(dp + HM_IDX_CODE);
 613   4      
 614   4                                      if(*(dp + HM_IDX_STAT) & HM_1STKEY){
 615   5                                              if(keyh_edg == 0){
 616   6                                                      keyh_edg = 1;
 617   6                                              }else{
 618   6                                                      *(dp + HM_IDX_STAT) &= ~HM_1STKEY;                      // only allow 1 1stkey in a row
 619   6                                              }
 620   5                                      }else{
 621   5                                              keyh_edg = 0;
 622   5                                      }
 623   4      
 624   4                                      if(d != KEY_NULL){                                                                      // trap first press, and prevent false repeats
 625   5                                              if(d == PTT_CODE){
 626   6                                                      i = d;
 627   6                                                      keyh_mem = KEY_NULL;
 628   6                                              }else{
 629   6                                                      dbounceHM_tmr = 150;                                            // reset loss-of-key detect timer
 630   6                                                      if(d && (d != keyh_mem)){                                       // if mic data is not null AND key mem is null:
 631   7                                                              keyh_mem = d;                                                   // save key to mem (first key)
 632   7                                                              i = d;
 633   7                                                      }else{
 634   7                                                              // process hold message
 635   7                                                              process_WR(K_HOLD);
 636   7                                                      }
 637   6                                              }
 638   5                                      }else{
 639   5                                              keyh_edg = 0;                                                                   // save null to key mem if debounce == 0
 640   5                                      }
 641   4                                      if(i & 0x80){
 642   5                                              delF1 = 0;
 643   5                                              delF2 = 0;
 644   5                                      }
 645   4                                      // process DTMF keys if PTT == 1, or send to remote host if PTT == 0
 646   4                                      if(((i>='0') && (i<='9')) || ((i>='A') && (i<='D')) || (i =='*') || (i == '#')){
 647   5                                              t = 1;
 648   5                                      }else{
 649   5                                              t = 0;
 650   5                                      }
 651   4                                      j = *(dp + HM_IDX_STAT) & HM_1STKEY;
 652   4                                      if(*(dp + HM_IDX_STAT) & (HM_PTT | HM_DTMF) == (HM_PTT | HM_DTMF) && !t){
 653   5                                              // DTMF-S PTT hold
 654   5                                              q = 1;
 655   5                                              delF1 = 0;
 656   5                                              delF2 = 0;
 657   5                                      }
 658   4              /*                      if(((*(dp + HM_IDX_STAT) & HM_PTT) == HM_PTT) && q){
 659   4                                              // DTMF-S release
 660   4                                              q = 0;
 661   4                                              MMUTE_N = UNMUTE_BIT;                                                   // (o) mic unmute out (act low)
 662   4                                      }*/
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 12  

 663   4                                      if(t){
 664   5                                              if(*(dp + HM_IDX_STAT) & HM_DTMF){
 665   6                                                      press_timer = MS1650;                                           // reset DTMF timer
 666   6                                              }
 667   5                                              if(*(dp + HM_IDX_STAT) & HM_PTT){
 668   6                                                      outbit(PTT, 1);
 669   6                                              }
 670   5                                              if(xport & PTT){
 671   6                                                      if(j){
 672   7                                                              PCA0CPM2 &= ~0x40;                                              // fn led off if dtmf (ECOM);
 673   7                                                              MMUTE_N = MUTE_BIT;                                             // (o) mic mute out (act low)
 674   7                                                              delF1 = dtmf_row[*(dp+HM_IDX_DTMF)];
 675   7                                                              delF2 = dtmf_col[*(dp+HM_IDX_DTMF)];
 676   7                                                      }
 677   6                                              }else{
 678   6                                                      // the chrs between '9' and 'A' are not possible, so they are included to simplify the code
 679   6                                                      if(((i >= '0') && (i <= 'D')) || (i == '*') || (i == '#')){     // send digit sub-matrix to remote host
 680   7                                                              process_WR(i);                                                  // send digit message                                                   
 681   7                                                      }
 682   6                                              }
 683   5                                      }else{
 684   5                                              switch(i){
 685   6                                                      // process top function buttons (non-dtmf)
 686   6                                                      case 'L':
 687   6                                                      case 'T':
 688   6                                                      case 'X':
 689   6                                                      case '/':
 690   6                                                      case 'V':
 691   6                                                      case 'M':
 692   6                                                      case '\\':
 693   6                                                      case 'F':
 694   6                                                      case 'G':
 695   6                                                              process_WR(i);                                                  // send digit message                                                   
 696   6                                                              break;
 697   6                                                      
 698   6                                                      default:
 699   6                                                              break;
 700   6                                              }
 701   5                                      } // end "key processing" branch
 702   4                              } // end "new events"
 703   3                      } // end while(run)
 704   2              } // end outer while()
 705   1      } // end main()
 706          
 707          // *********************************************
 708          //  *************** SUBROUTINES ***************
 709          // *********************************************
 710          
 711          //-----------------------------------------------------------------------------
 712          // flash_swvers() uses ms timer to pulse out Morse data on LED
 713          //      "pattern" is dit(0) or dah(1).  1st element is pointed to by "mask"
 714          //              subsequent elements are toward the LSb of pattern (mask is right shifted
 715          //              to reach next element).  When mask == 0, character is done.  There is
 716          //              a DAH delay on entry and exit.
 717          //-----------------------------------------------------------------------------
 718                  
 719          #define MORSE_PER       MS80    // dit period
 720          
 721          void flash_swvers(U8 pattern, U8 mask){
 722   1              idata U8        j = 0;                  // temp vars
 723   1      volatile        U8      k = mask;               // vers pattern temps
 724   1      
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 13  

 725   1              PCA0CPM2 &= ~0x40;                                                              // led dim (ECOM)
 726   1              ud_timer = (3 * MORSE_PER);
 727   1              ud_timer_flag = TRUE;
 728   1              while(ud_timer_flag);
 729   1              do{
 730   2                      process_WR(0);                                                          // process wired-remote
 731   2                      PCA0CPM2 &= ~0x40;                                                      // led dim (ECOM)
 732   2                      ud_timer = MS100;
 733   2                      ud_timer_flag = TRUE;
 734   2                      while(ud_timer_flag);
 735   2                      PCA0CPM2 |= 0x40;                                                       // led brt (ECOM)
 736   2                      if(pattern & k){
 737   3                              ud_timer = (3 * MORSE_PER);
 738   3                      }else{  
 739   3                              ud_timer = MORSE_PER;
 740   3                      }
 741   2                      ud_timer_flag = TRUE;
 742   2                      k = k >> 1;
 743   2                      process_WR(0);                                                          // process wired-remote
 744   2                      while(ud_timer_flag);
 745   2                      j = got_hmd();
 746   2                      j |= ~PTTM_N;
 747   2              }while((j == 0) && k);
 748   1              if(j == 0){                                                                             // if there was no keypress or ptt, delay
 749   2                      PCA0CPM2 &= ~0x40;                                                      // led dim (ECOM)
 750   2                      ud_timer = (3 * MORSE_PER);
 751   2                      ud_timer_flag = TRUE;
 752   2                      while(ud_timer_flag);
 753   2              }
 754   1              PCA0CPM2 |= 0x40;                                                               // led brt (ECOM)
 755   1              return;
 756   1      }
 757          
 758          //-----------------------------------------------------------------------------
 759          // pulse() uses ms timer to pulse discretes pcount pulses
 760          //-----------------------------------------------------------------------------
 761          /*
 762          void pulse(U8 discr, U8 pcount, U16 pdly){
 763          data    U8      i;              // temp vars
 764          data    U8      j;
 765          
 766                  if(pcount == 0){
 767                          j = 1;
 768                  }else{
 769                          j = pcount;
 770                          press_timer = 100;                                                      // set some delay
 771                          press_flag = 0;
 772                          do{
 773                                  i = got_hmd();
 774                                  if(i){
 775                                          get_hmd();                                                      // clear data word buffer
 776                                          press_timer = 80;
 777                                          press_flag = 0;
 778                                  }
 779                          }while(!press_flag);
 780                  }
 781                  for(i=0; i<j; i++){
 782                          PCA0CPM2 &= ~0x40;                                                      // led dim (ECOM)
 783                          outbit(discr, 1);
 784                          ud_timer = pdly;
 785                          ud_timer_flag = TRUE;
 786                          while(ud_timer_flag);
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 14  

 787                          PCA0CPM2 |= 0x40;                                                       // led brt (ECOM)
 788                          outbit(discr, 0);
 789                          ud_timer = pdly;
 790                          ud_timer_flag = TRUE;
 791                          while(ud_timer_flag);
 792                          if(got_hmd()){
 793                                  i = j;                                                                  // a keypress detected, abort
 794                          }
 795                  }
 796                  return;
 797          }
 798          */
 799          //************************************************************************
 800          // outbit() consolodates OC output port updates into a single function
 801          //************************************************************************
 802          void outbit(U8 bitmap, U8 on){
 803   1              // This is the version 1 routine.  Only PTT, UP, DN, & F2 (MW) are supported
 804   1              switch(bitmap){
 805   2                      case PTT:
 806   2                              if(on){
 807   3                                      PTTb = 1;
 808   3                                      xport |= bitmap;
 809   3                              }else{
 810   3                                      PTTb = 0;
 811   3                                      xport &= ~bitmap;
 812   3                              }
 813   2                              break;
 814   2                      
 815   2                      case UP:
 816   2      //                      if(on) UPb = 1;
 817   2      //                      else UPb = 0;
 818   2                              break;
 819   2                      
 820   2                      case DN:
 821   2      //                      if(on) DNb = 1;
 822   2      //                      else DNb = 0;
 823   2                              break;
 824   2                      
 825   2                      case DN2:
 826   2                              if(on) DMUTE = 1;
 827   2                              else DMUTE = 0;
 828   2                              break;
 829   2                      
 830   2                      default:
 831   2                              break;
 832   2              }
 833   1              return;
 834   1      }
 835          
 836          // ******************* HM keypress capture ******************
 837          
 838          //************************************************************************
 839          // wait() waits the U8 value then returns.
 840          //************************************************************************
 841          void wait(U8 wvalue){
 842   1      
 843   1              waittimer = wvalue;                                                             // set the timer
 844   1              while(waittimer);                                                               // wait for it to expire
 845   1              return;
 846   1      }
 847          
 848          //-----------------------------------------------------------------------------
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 15  

 849          // got_hmd() returns true if HM-133/151 data buffer not empty
 850          //-----------------------------------------------------------------------------
 851          U8 got_hmd(void){
 852   1              bit     rtn = 0;
 853   1      
 854   1              if(hm_tptr != hm_hptr){
 855   2                      rtn = 1;
 856   2              }
 857   1              return (U8)rtn;
 858   1      }
 859          
 860          //-----------------------------------------------------------------------------
 861          // get_hmd() returns HM-133/151 data/status or -1 if no data
 862          //-----------------------------------------------------------------------------
 863          S32 get_hmd(void){
 864   1              idata S32       rtn = -1L;
 865   1      
 866   1              if(hm_tptr != hm_hptr){
 867   2                      rtn = (S32)(hm_buf[hm_tptr] & 0x00ffffff) | ((S32)hm_status_buf[hm_tptr] << 24);
 868   2                      if(++hm_tptr > (HM_BUFMAX-1)) hm_tptr = 0;
 869   2              }
 870   1              return rtn;
 871   1      }
 872          
 873          //-----------------------------------------------------------------------------
 874          // get_hmcode() returns pointer to keycode array
 875          //      1st index is key-data status
 876          //      2nd index is keycode (KEY_NULL if invalid data)
 877          //      3rd index is DTMF tone offset index
 878          //-----------------------------------------------------------------------------
 879          char* get_hmcode(U32 keym){
 880   1              U16             ii;                                     // temps
 881   1              U8              i;
 882   1              U8              di = 0;                         // dtmf index temp
 883   1      static idata char       hm_rtn[3];      // holding array for code and status data
 884   1                                                                      // 0 = stat, 1 = code, 2 = DTMF idx
 885   1      
 886   1              hm_rtn[HM_IDX_CODE] = KEY_NULL;
 887   1              hm_rtn[HM_IDX_STAT] = (U8)keym & 0x0f;                                          // get key status
 888   1              ii = (U16)(keym >> 4);                                                                          // conv hm151/133 keymatrix to keyaddr (low nyb is status)
 889   1              if(ii == 0x0002){                                                                                       // HM-133 PTT
 890   2                      hm_rtn[HM_IDX_CODE] = PTT_CODE;                                                 // semicolon is PTT
 891   2              }else{
 892   2                      if(ii != 0xffff){
 893   3                              i = 0;
 894   3                              do{
 895   4                                      if(ii == key_addr[i]){  
 896   5                                              hm_rtn[HM_IDX_CODE] = key_code[i];                      // look for match in fn LUT
 897   5                                              di = i;
 898   5                                      }
 899   4                              }while((hm_rtn[HM_IDX_CODE] == KEY_NULL) && key_addr[++i]);     // loop exits when match or end of LUT
 900   3                              if(hm_rtn[HM_IDX_CODE] == KEY_NULL){
 901   4                                      sys_error_flags |= HM_DATA_ERR;
 902   4                              }
 903   3                              hm_rtn[HM_IDX_DTMF] = di - DTMF_OFFS;
 904   3                      }
 905   2              }
 906   1              return hm_rtn;
 907   1      }
 908          
 909          //-----------------------------------------------------------------------------
 910          // wr_timeout() sets or reads the wired remote "key hold" pacing timer
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 16  

 911          //      if param = 0, return FALSE if timer == 0, else true
 912          //      else, set timer and return
 913          //-----------------------------------------------------------------------------
 914          char wr_timeout(U16 toval){
 915   1              bit     EA_save;
 916   1      
 917   1              if(toval != 0){
 918   2                      EA_save = EA;                                   // prohibit intrpts
 919   2                      EA = 0;
 920   2                      wr_timer = toval;
 921   2                      wr_flag = 0;
 922   2                      EA = EA_save;                                   // re-set intrpt enable
 923   2              }
 924   1              return wr_flag;
 925   1      }
 926          
 927          void wr_clr(void){
 928   1              bit     EA_save;
 929   1      
 930   1              EA_save = EA;                                   // prohibit intrpts
 931   1              EA = 0;
 932   1              wr_timer = 0;
 933   1              wr_flag = 0;
 934   1              EA = EA_save;                                   // re-set intrpt enable
 935   1              return;
 936   1      }
 937          
 938          //-----------------------------------------------------------------------------
 939          // wra_timeout() sets or reads the wired remote abort timeout timer
 940          //      if param = 0, return FALSE if timer == 0, else true
 941          //      else, set timer and return
 942          //-----------------------------------------------------------------------------
 943          char wra_timeout(U16 toval){
 944   1              bit     EA_save;
 945   1      
 946   1              if(toval != 0){
 947   2                      EA_save = EA;                                   // prohibit intrpts
 948   2                      EA = 0;
 949   2                      wra_timer = toval;
 950   2                      wra_flag = 0;
 951   2                      EA = EA_save;                                   // re-set intrpt enable
 952   2              }
 953   1              return wra_flag;
 954   1      }
 955          
 956          //-----------------------------------------------------------------------------
 957          // pca_intr
 958          //-----------------------------------------------------------------------------
 959          //
 960          // Called when PCA CEX0 input RE event is detected:
 961          //      This event is rising edge from the HM-151/151 data line.  HM-133/151 data is a
 962          //              serial format that features a 195us low followed by a 230us high
 963          //              (logic "0") or a 415us high (logic "1").  NOTE: The data line is
 964          //              inverted at the input of the MCU (by the comparator).  7 zeros plus a
 965          //              750us low is a sync pulse (start of a 2-word frame)
 966          //
 967          //      HM-151 Keys send bursts of 2 data words at a 43-60 ms rate (measured at
 968          //              about 50 ms on a single device).
 969          //
 970          //      This timer measures the time between rising edges (as seen at MCU pin) and
 971          //              determines if the transitions represent a 1, 0, or sync pulse.  An
 972          //              application timer is used to establish a previous period of no edge
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 17  

 973          //              activity. (this resets the serial input state machine).
 974          //              The messages are 19 bits plus a stop bit.  Since the timer looks for
 975          //              falling edges, and bursts consist of two words, only the 1st word's
 976          //              stop bit will be captured.  Thus, the first word after a long idle or
 977          //              a sync pulse will count 20 bits until the data is captured.  The 2nd
 978          //              word triggers a capture after only 19 bits.  This saves the expense
 979          //              of configuring another timer ISR to establish the end of the 2nd word's
 980          //              stop bit.
 981          //              Once captured, the data word is stored to the FILO buffers (hm_buf[]
 982          //              for data, hm_status_buf[] for status) for processing by the process loops.
 983          //              NOTE: Data consumers must extract both the data and status before
 984          //              updating the tail pointer.
 985          //
 986          //              Keycode matrix:
 987          //              LOCK (L)        TUNER (T)       XFC (X)
 988          //              0b020           13020           23020
 989          //
 990          //              upARROW (/)             V/M (V) MW (M)
 991          //              22020                   0a020   12020
 992          //
 993          //              dnARROW (\)             F1 (F)  F2 (f)
 994          //              20020                   10020   08020
 995          //
 996          //              1               2               3               MODE (A)
 997          //              0b820   13820   23820   43820
 998          //
 999          //              4               5               6               FIL  (B)
1000          //              09820   11820   21820   41820
1001          //
1002          //              7               8               9               GENE (C)
1003          //              0a820   12820   22820   42820
1004          //
1005          //              . (*)   0               CE (#)  ENT  (D)
1006          //              08820   10820   20820   40820
1007          //
1008          //              HM-133:
1009          //              (1) 00002 (1) = PTT pressed
1010          //              (3) 00002 (0) = PTT release
1011          //-----------------------------------------------------------------------------
1012          
1013          void pca_intr(void) interrupt 9 using 2{
1014   1              // HM-133/151 data decode vars
1015   1              U8              temp;                           // temp ptr reg
1016   1              U16             captim;                         // capture time holding reg
1017   1              U16             captemp;                        // capture time temp reg
1018   1              
1019   1          if(CCF0 == 1){
1020   2                              CCF0 = 0;                                                       // clr intr flag
1021   2      
1022   2                              captim = (U16)PCA0L;                                                    // grab time of edge
1023   2                              captim |= ((U16)PCA0H) << 8;
1024   2                              if(captim < last_edge){                                                 // calc pulse duration (in SYSCLK tics)
1025   3                                      captemp = 65535 - last_edge + captim;           // if rollover
1026   3                              }else{
1027   3                                      captemp = captim - last_edge;                           // normal timer progression
1028   3                              }
1029   2                              if(captemp < HMT_MIN) return;                                   // ignore if pulse too short
1030   2                              last_edge = captim;                                                             // save new edge
1031   2                              if(hmd_timer == 0){                                                             // look for LOS timeout
1032   3                                      // reset data & mask
1033   3                                      dmask = 0x01;                                                           // reset data/status regs
1034   3                                      bit_count = 0;
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 18  

1035   3                                      hm_data = 0;
1036   3                                      hm_status = 0;
1037   3                                      hmd_timer = HMD_BURST_TO;                                       // reset burst timer
1038   3                              }else{
1039   3                                      hmd_timer = HMD_BURST_TO;                                       // reset 5ms timer
1040   3                                      if(captemp < HMT_0){                                            // check if pulse is a "0"
1041   4                                              dmask = dmask << 1;                                             // shift dmask...0 in data is implicit
1042   4                                              bit_count++;                                                    // update bit count
1043   4                                      }else{
1044   4                                              if(captemp < HMT_1){                                    // check if pulse is a "1"
1045   5                                                      hm_data |= dmask;                                       // place a "1" into the data reg
1046   5                                                      dmask = dmask << 1;                                     // shift dmask
1047   5                                                      bit_count++;                                            // update bit count
1048   5                                              }else{
1049   5                                                      if(captemp < HMT_SYNC){ // if sync pulse (opt, && sync preamble),
1050   6                                                              dmask = 0x01;                                   // reset data input registers (discard old data)
1051   6                                                              hm_data = 0;
1052   6                                                              bit_count = 0;
1053   6                                                              hm_status |= HM_START;                  // set start of frame
1054   6                      /*                                      if((!((hm_data >> (bit_count-7)) & 0x7F)) && (bit_count > 6)){
1055   6                                                                      if((!((hm_data >> (bit_count-7)) & 0x7F)) && (bit_count > 6)){
1056   6                                                                      hm_status |= HM_START;          // set start if proper sync
1057   6                                                              }else{
1058   6                                                                      hm_status |= HM_ERROR;          // else set error
1059   6                                                              }*/
1060   6                                                      }else{
1061   6                                                              hm_status |= HM_ERROR;                  // else set error
1062   6                                                      }
1063   5                                              }
1064   4                                      }
1065   3                                      if(bit_count == 20){                                            // if 20 bits, capture data & status
1066   4                                              temp = hm_hptr;                                                 // save ptr in case we overflow
1067   4                                              hm_buf[hm_hptr] = hm_data;
1068   4                                              hm_status_buf[hm_hptr++] = hm_status;
1069   4                                              if(hm_hptr > (HM_BUFMAX-1)) hm_hptr = 0; // roll-over head pointer
1070   4                                              if(hm_hptr == hm_tptr) hm_hptr = temp;  // buffer overflow, don't advance head
1071   4                                              dmask = 0x01;                                                   // reset data regs
1072   4                                              hm_data = 0;
1073   4                                              bit_count = 1;                                                  // only look for 19 bits on the 2nd try
1074   4                                              hm_status = 0;
1075   4                                      }
1076   3                              }
1077   2                      }
1078   1                      return;
1079   1      }
1080          
1081          //-----------------------------------------------------------------------------
1082          // Timer0_ISR
1083          //-----------------------------------------------------------------------------
1084          //
1085          // Called when timer 0 overflows (NORM mode):
1086          //      drives bbSPI by shifting 8 bits out MOSI at the timer rate/2 (the timer
1087          //                      sets the half clock period).
1088          //              If T0 enabled with spmask = 0, nothing happens except T0 is disabled when
1089          //                      the interrupt happens.  This is used to time the strobe pulse (external
1090          //                      code handles the strobe set/clear).
1091          //
1092          //-----------------------------------------------------------------------------
1093          
1094          void Timer0_ISR(void) interrupt 1
1095          {
1096   1              TR0 = 0;                                                                                // shouldn't get here, but turn off intrpt if we do
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 19  

1097   1              return;
1098   1      }
1099          
1100          //-----------------------------------------------------------------------------
1101          // Timer1_ISR
1102          //-----------------------------------------------------------------------------
1103          //
1104          // Called when timer 1 overflows (NORM mode):
1105          //      drives DDS
1106          //
1107          //-----------------------------------------------------------------------------
1108          /*
1109          void Timer1_ISR(void) interrupt 3 using 2
1110          {
1111                  // DDS vars
1112                  U8              pac;                            // temp regs
1113                  U16             pdac;
1114                  static U16      phaccum1;               // tone 1 phacc
1115                  static U16      phaccum2;               // tone 2 phacc
1116          
1117              TF1 = 0;                                                    // Clear Timer2 interrupt flag
1118                  
1119                  if(ipldds){
1120                          phaccum1 = 0;
1121                          phaccum2 = 0;
1122                          ipldds = 0;
1123                  }
1124                  // process phase accumulator 1
1125                  phaccum1 += delF1;                                                              // add delta for tone 1
1126                  pac = (U8)(phaccum1 >> 8);
1127                  pdac = (U16)SINE[pac];
1128          
1129                  // process phase accumulator 2
1130                  phaccum2 += delF2;                                                              // add delta for tone 2
1131                  pac = (U8)(phaccum2 >> 8);
1132                  pdac += (U16)SINE[pac];                                                 // add tone 2 DAC to holding reg
1133                  pdac >>= 1;                                                                             // div by 2 to get 8 bit combined tone DAC value
1134                  // store pdac to pwm
1135                  PCA0CPH1 = (U8)pdac;                                                    // storing here to sync update
1136          }*/
1137          
1138          //-----------------------------------------------------------------------------
1139          // Timer2_ISR
1140          //-----------------------------------------------------------------------------
1141          //
1142          // Called when timer 2 overflows (NORM mode):
1143          //      updates app timers @ 10ms rate
1144          //              rate = (sysclk/12) / (65536 - TH:L)
1145          //
1146          //-----------------------------------------------------------------------------
1147          
1148          void Timer2_ISR(void) interrupt 5 using 2
1149          {
1150   1              // DDS vars
1151   1              U8              pac;                            // temp regs
1152   1              U16             pdac;
1153   1              static U16      phaccum1;               // tone 1 phacc
1154   1              static U16      phaccum2;               // tone 2 phacc
1155   1      
1156   1          TF2H = 0;                                                   // Clear Timer2 interrupt flag
1157   1      
1158   1              if(ipldds){
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 20  

1159   2                      phaccum1 = 0;
1160   2                      phaccum2 = 0;
1161   2                      ipldds = 0;
1162   2              }
1163   1              // process phase accumulator 1
1164   1              phaccum1 += delF1;                                                              // add delta for tone 1
1165   1              pac = (U8)(phaccum1 >> 8);
1166   1              pdac = (U16)SINE[pac];
1167   1      
1168   1              // process phase accumulator 2
1169   1              phaccum2 += delF2;                                                              // add delta for tone 2
1170   1              pac = (U8)(phaccum2 >> 8);
1171   1              pdac += (U16)SINE[pac];                                                 // add tone 2 DAC to holding reg
1172   1              pdac >>= 1;                                                                             // div by 2 to get 8 bit combined tone DAC value
1173   1              // store pdac to pwm
1174   1              PCA0CPH1 = (U8)pdac;                                                    // storing here to sync update
1175   1      
1176   1              // U8 timers
1177   1              if(--t2pscl == 0){
1178   2                      t2pscl = T2_MS1PS;                                                      // reset ms prescaler
1179   2                      if(waittimer != 0){                             // g.p. delay timer
1180   3                              waittimer--;
1181   3                      }
1182   2                      if(dbounceHM_tmr != 0){                         // pbsw debounce timer
1183   3                              dbounceHM_tmr--;
1184   3                      }
1185   2                      // U16 timers
1186   2                      if(hmkey_timer){
1187   3                              if(--hmkey_timer){
1188   4                                      hmkey_timer_flag = 0;
1189   4                              }
1190   3                      }
1191   2                      if(ud_timer){                                                           // key timer
1192   3                              if(--ud_timer == 0){
1193   4                                      ud_timer_flag = 0;
1194   4                              }
1195   3                      }
1196   2                      if(press_timer){                                                        // key press timer and flag
1197   3                              press_timer--;
1198   3                              if(!press_timer){
1199   4                                      press_flag = 1;
1200   4                              }
1201   3                      }
1202   2                      if(wr_timer != 0){                                                      // wired-remote timer and flag
1203   3                              wr_timer -= 1;
1204   3                              if(wr_timer == 0){
1205   4                                      wr_flag = 1;
1206   4                              }
1207   3                      }
1208   2                      if(wra_timer != 0){                                                     // wired-remote timer and flag
1209   3                              wra_timer -= 1;
1210   3                              if(wra_timer == 0){
1211   4                                      wra_flag = 1;
1212   4                              }
1213   3                      }
1214   2              }
1215   1      }
1216          
1217          //#undef IS_MAINC
1218          //**************
1219          // End Of File
1220          //**************
C51 COMPILER V9.55   MAIN                                                                  06/27/2022 22:15:57 PAGE 21  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2351    ----
   CONSTANT SIZE    =    165    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     51      27
   IDATA SIZE       =     34       9
   BIT SIZE         =      6       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
